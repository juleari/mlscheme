% Компоненты среды разработки --- 5
\section{Компоненты среды разработки}
    Компилятор языка состоит из пяти основных компонентов.
    К ним относятся: чтение входного потока, лексический, синтаксический и семантический анализаторы и генератор кода.
    \subsection{Чтение входного потока}
    На этом этапе происходит чтение текста программы из файла и предварительное его разделение на <<слова>>.

    <<Словом>> является:
    \begin{itemize}
        \item любая последовательность символов, заключённая в двойные кавычки;
        \item любой терминальный символ (символ переноса строки, пробел, табуляция, окончание файла);
        \item последовательность символов, образующая слово $scheme$, если она не входит в состав другого <<слова>>;
        \item последовательность символов, заключённых в круглые скобки, следующая за словом $scheme$ и отделённая от него одним или несколькими <<словами>>, являющимися терминальными символами;
        \item любая иная последовательность символов, не содержащая терминальных символов.
    \end{itemize}

    После этого этапа мы получаем список <<слов>>, который подаётся на вход лексическому анализатору.
    
    \subsection{Лексический анализ}
    На этом этапе осуществляется преобразование последовательности <<слов>> в последовательность токенов.
    Это происходит по следующей схеме.

    Сначала проверяется, входит ли данное <<слово>> в список ключевых слов.
    Если проверка оказывается успешной, то вычисляются координаты и создаётся токен с тэгом \verb$tag-kw$, значением которого будет являтся само <<слово>>.
    При этом, если ключевое слово является словом $scheme$, то ближайшее следующее за ним нетерминальное слово будет значением нового токена с тэгом \verb$tag-schm$.

    Затем осуществляется проверка является ли <<слово>> корректным числом.
    Если так, то высчитываются его координаты и создаётся токен с числовым тэгом.
    Значению этого токена присваивается вычисленное на этапе проверки число.

    После этого проверяется, является ли <<слово>> <<строкой>>, то есть последовательностью символов, заключённых в кавычки.
    Аналогично предыдущим пунктам вычисляются координаты и создаётся новый токен с тэгом \verb$tag-str$.

    В случае, если ни одна из этих проверок не увенчалась успехом, данное <<слово>> преобразуется в последовательность символов и дальнейшая проверка будет по-символьной.

    Если среди последовательности символов нам встретился символ $;$, дальнейшие символы этого <<слова>> и последующих игнорируются, пока не встретится символ переноса строки.

    Если среди последовательности символов встречается один из следующих: \verb!( ) [ ] { } . :!, то эта последовательность разбивается на три части:
    \begin{enumerate}
        \item сам символ;
        \item последовательность символов до него (возможно, пустая);
        \item последовательность символов после (возможно, пустая).
    \end{enumerate}
    Первая часть преобразуется в токен, с тэгом, соответствующем символу.
    Вторая и третья подвергаются анализу как отдельные <<слова>>.

    Для каждого элемента группы символов \verb,\ < ^ # !,, существует свой тэг.
    Но он останется у токена, только если этот символ был в <<слове>> единственным.

    Итоговый тэг для следующей группы символов: \verb!- + * t f / > | & =! определяется по тому является ли символ первым в слове или он следует за каким-то другим.
    Например, символ $-$ может получить тэг \verb$tag-mns$, если этот символ в слове первый.
    Если перед ним в <<слове>> стоит символ $<$ с тэгом \verb$tag-lwr$, то итоговый тэг изменится на \verb$tag-to$.
    Но если перед символом $-$ стоит какой-то другой символ или последовательность, то итоговый тэг будет --- \verb$tag-sym$, и вся эта последовательность станет токеном идентификатора.
    
    \subsection{Синтаксический анализ}
    Синтаксический анализ осуществляется с помощью метода рекурсивного спуска.
    При этом разбор математических выражений осуществляется с помощью алгоритма сортировочной станции.
        \subsubsection{Метод рекурсивного спуска}
        Для каждого нетерминала, описанного в пункте 2 создаётся функция.
        В этой функции сначала определяется вложенность токена по отступу.
        Затем проверяется выполнение правила грамматики, определяющего нетерминал\cite{skor}.

        Текущий токен, хранится в глобальной для функций-правил переменной.
        Входная функции соответствует правилу $Program$.

        При возникновении ошибки, она записывается и список ошибок и продолжается проверка.
        После обработки последнего токена печатается печатается список ошибок с указанием координат ошибки и сообщением о её типе.

        \subsubsection{Алгоритм сортировочной станции}
        Для будущей возможности определения функций-операторов с приоритетами операторов для разбора выражений был выбран алгоритм сортировочной станции.
        В случае корректного математического выражения мы получим его запись в обратной польской нотации.
        Выражения на Scheme имеют прямую польскую запись.
        Поэтому для их вычисления, понадобится только преобразовать обратную польскую запись к прямой.

    \subsubsection{Дерево разбора}
    Синтаксический анализатор возвращает дерево разбора.
    Для функции вычисления факториала, описанной в пункте 1, и её вызовов 
    \\ \verb,n! 5,
    \\ \verb,n! 10
    \\ будет построено следующее дерево:

    \lstinputlisting{examples/ast_factorial}
    \subsection{Семантический анализ}
    Семантический анализатор принимает синтаксическое дерево, созданное в процессе синтаксического анализа.
    Семантический анализатор составляет модель программы, которая состоит из таблицы символов и списка выражений.

    Проходя по синтаксическому дереву семантический анализатор составляет таблицу символов --- отображение идентификаторов символов, в описания соответствующих этим символам сущностей\cite{skor}.
    Здесь символ --- именованная сущность, определяемая парой \verb!<name, info>!, где \verb,name, --- идентификатор сущности, а \verb,info, --- её описание.

    Описание символа представляет собой список возможных значений этого символа.
    Одно такое значение хранится в виде вектора из трёх элементов:
    \begin{enumerate}
        \item описания аргументов;
        \item списка внутренних определений;
        \item списка выражений.
    \end{enumerate}

    Описание аргументов также является вектором, но состоящим из четырёх элементов:
    \begin{enumerate}
        \item функции проверки количества аргументов;
        \item списка функций проверки значений аргументов;
        \item списка имён аргументов;
        \item функции проверки равенства аргументов с одинаковыми идентификаторами.
    \end{enumerate}
    Все эти функции создаются в процессе семантического анализа.

    Повторяющиеся имена заменяются на те, которые не могут быть идентификаторами Языка, но являются корректными в Scheme.
    Для замены создаётся имя, начинающееся с двоеточия.
    Таким же образом заменяются цифры.
    Для списков хранится список имён.
    <<Продолжения>> записываются в виде \verb,(:continuous xs), где \verb/xs/ -- имя переменной, в которой будут хранится все неописанные в основном списке аргументы.

    Функции проверки количества аргументов отличаются для функций, у которых в списке аргументов есть <<продолжения>> и нет.
    Для первых --- это проверка на то, что аргументов не меньше, чем перечислено до <<продолжения>>.
    Для вторых --- проверка количества на равенство.

    Список внутренних определений является таблицей символов.

    Список выражений является промежуточным вариантом их представления между синтаксическим деревом и итоговым сгенерированным кодом.
    Выполняется преобразование вызовов функций и применения функций в удобный для итоговой генерации вид.

    Когда встречается вызов функции осуществляется проверка существования соответствующего символа в таблице и выполняются проверки аргументов.
    В случае если такой символ не найден или если список аргументов не соответствует ни одному из описания --- в список ошибок семантического анализатора добавляется ошибка с описанием.

    Для синтаксического дерева, приведённого в предыдущем пункте получена следующая модель программы:
    
    \lstinputlisting{examples/model_factorial}
    
    \subsection{Генерация кода}
    
