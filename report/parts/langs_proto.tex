% Языки-прототипы --- 7
\section{Языки-прототипы}
    \subsection{Семейство языков Lisp, язык Scheme}
        $Lisp$ (LISt Processing language) --- функциональный язык программирования с динамической типизацией. 
        Он был создан для символьной обработки данных~\cite{p_c_lisp}.
        $Scheme$ --- диалект Lisp'а, использующий хвостовую рекурсию и статические области видимости переменных~\cite{scheme_doc}.
        Scheme --- высокоуровевый язык общего назначения, поддерживающие операции над такими структурами данных как строки, списки и векторы.

        Язык Scheme был создан как учебный, однако, в последнее время используется для написания текстовых редакторов, оптимизирующих компиляторов, операционных систем, графических пакетов и экспертных систем, вычислительных приложений и систем виртуальной реальности.
        Язык оказал сильное влияние на многие современные языки программирования, такие как Haskell (и языки семейства ML в целом), Rust, Python, JavaScript.

        В Scheme реализована <<сборка мусора>>.
        
        Все объекты, в том числе функции, являются данными первого порядка, что позволяет присваивать функции переменным, возвращать функции и принимать их в качестве аргументов.
        Все переменные и ключевые слова объедены в области видимости, а программы на языке имеют блочную структуру.
        
        Как и во многих других языках программирования процедуры на языке Scheme могут быть рекурсивными.
        Все хвостовые рекурсии оптимизируются.

        Scheme поддерживает определение произвольных структур с помощью \textit{продолжений}.
        Продолжения сохраняют текущее состояние программы и позволяют продолжить выполнение с этого момента из любой точки программы.
        Этот механизм удобен для перебора с возвратом, многопоточности и сопрограмм~\cite{scheme_pl}.

        Scheme также позволяет создавать синтаксические расширения для написания процедур трансформации новых синтаксических форм в существующие~\cite{scheme_pl}.

        Функции на языке Scheme могут иметь произвольное число аргументов.
        Тем переменным, наличие которых необходимо, присваиваются имена, а остальные можно получить из списка оставшихся.

        В Scheme есть статические переменные --- долговременные переменные, существующие на протяжении функции.
        Они отличаются от глобальных переменных тем, что существуют только внутри функции, могут хранить свои значения между вызовами, но при этом не доступы извне.
        Это позволяет организовывать мемоизацию (сохранение результатов выполнения функций для предотвращения повторных вычислений).
        Это является одним из способов оптимизации.
        При использовании оптимизации перед началом вычислений проверяется вызывалась ли ранее эта функция с этим набором аргументов.
        Если не вызывалась, то результат вычисляется, сохраняется в статической переменной и возвращается.
        Если функция уже вызывалась с данным набором аргументов, то возвращается сохранённый ранее результат.
        
        Язык Scheme обладает полноценными средствами символьной обработки.

        В Scheme используется префиксная нотация.
        Выражения являются списками с оператором во главе этого списка.
        Такой способ записи позволяет, например, сложить сразу несколько значений.
        Но выражения с несколькими операторами трудны для восприятия из-за большого количества скобок.
        Это требует от разработчика использовать специализированные текстовые редакторы, поддерживающие контроль парности скобок и принятый стиль форматирования кода.
        Таких редакторов немного, и они либо недружелюбны к начинающему программисту (Emacs, vim), либо ориентированы на определённый диалект языка (Racket).

        В языке Scheme всё представлено в виде списков.
        Таким способ представления код не отличается от способа представления данных.
        Это позволяет работать с кодом как с данными.

        Пример функции вычисления факториала числа, написанный на языке Scheme:

        \lstinputlisting{examples/scheme_factorial}

    \subsection{Язык Prolog}
        $Prolog$ (PROgramming in LOGic) --- язык, объединяющий в себе логическое и алгоритмическое программирование.
        Этот язык специально разрабатывался для систем обработки естественных языков, исследований искуственного интеллекта и экспертных систем.
        В настоящее время этот язык применяется не очень широко~\cite{TIOBE}, хотя современный Prolog во многом является языком программирования общего назначения.

        Язык использует сопоставление с образцом (в том числе повторное использование).
        Сопоставление с образцом в языке Prolog базируется на унификации, в частности используя алгоритм Мартелли-Монтэнери~\cite{unify}.
        Этот алгоритм сопоставляет значения двух элементов выражения, находящихся на одинаковой позиции и в случае успеха приравнивает значения на других позициях.

        Ключевыми особенностями языка Prolog являются унификация и перебор с возвратом.
        Унификация показывает как две произвольные структуры могут быть равными.
        Процессоры Prolog'а используют стратегию поиска, которая пытается найти решение проблемы перебором с возвратом по всем возможным путям, пока один из них не приведёт к решению~\cite{prolog}
        Программа на языке Prolog представляет собой набор фактов и правил.

        Входной точкой в программу на языке Prolog является запрос.
        Ответом на него может быть либо список подошедших шаблонов, либо \verb!false!, означающий, что совпадений не найдено.

        Рассмотрим пример программы на языке Prolog.

        \lstinputlisting{examples/prolog_def}

        Эта программа состоит из трёх предложений, каждое из которых объявляет один факт об отношении $street$.
        Например, факт $street( moscow, arbat )$ описывает, что улица $arbat$ относится к $moscow$.
        После передачи соответствующей программы в систему Prolog последней можно задать некоторые вопросы об отношении $street$.
        Например, можно узнать все города, в которых есть улица $arbat$.
        Сделать это можно введя в терминал следующий запрос:

        \lstinputlisting{examples/prolog_call}

        После этого Prolog начнёт отыскивать все пары город-улица, где улица --- $arbat$.
        Решения отображаются на дисплее по одному до тех пор, пока Prolog получает указание найти следующее решение (в виде точки с запятой) или пока не будут найдены все решения~\cite{prolog_bratko}.
        Ответы выводятся следующим образом:

        \lstinputlisting{examples/prolog_res}

    \subsection{Семейство языков ML, Язык OCaml}
        $ML$ (Meta Language) --- семейство языков с полиморфным выводом типов и обработкой исключений.
        Языки ML не являются чистыми функциональными языками.
        
        $OCaml$ --- самый распространённый в практической работе диалект ML.

        Он включает в себя <<сборку мусора>> для автоматического управления памятью.
        Как и в Lisp, функции являются объектами первого класса.
        Это значит, что функции можно передавать в качестве аргумента, возвращать в качестве значения и присваивать их переменным.

        OCaml использует статическую проверкую типов, что позволяет увеличить скорость сократить количество ошибок во время исполнения.
        При этом поддерживается параметрический полиморфизм --- свойство семантики системы типов, позволяющее обрабатывать данные разных типов идентичным образом.
        Это даёт возможность создавать абстракции и работать с разными типами данных.

        Механизм автоматического вывода типов позволяет избегать тщательного определения типа каждой переменной, вычисляя его по тому как она используется.
        Кроме того, в OCaml, как и в Scheme, есть поддержка неизменяемых данных.

        Также, поддерживаются алгебраические типы данных и сопоставление с образцом, чтобы определять и управлять сложными структурами данных~\cite{ocaml}.
        Пример вычисления факториала числа на языке OCaml, используя сопоставление с образцом:

        \lstinputlisting{examples/ocaml_factorial}

    \subsection{Язык Haskell}
        $Haskell$ --- чистый функциональный язык программирования общего назначения.
        <<Чистота>> означает, что результат вычислений, производимых функциями не зависит от состояния программы.
        Он зависит только от набора входных параметров, а значит, уже вычисленные значения не изменятся.
        А значит, при следующем вызове функции с таким же набором фактических аргументов это значение можно уже не вычислять.

        Кроме того, Haskell является ленивым, что позволяет не вычислять значения, пока это не нужно.
        <<Ленивость>> ускоряет работу программы, однако позволяет допускать ошибки, так как выражение, содержащее ошибку может быть невыполнено.

        Haskell обладает статической сильной полной типизацией с атоматическим выводом типов.
        
        Также, Haskell поддерживает функции высшего порядка и частичное применение.

        Haskell ограниченно используется для написания сценариев.
        Дело в том, что Haskell удлиняет код для коротких скриптов за счёт статической типизации и необходимости использования монад, для организации императивного кода и функций с побочными эффектами.
        Это приводит также к усложнению кода, к введению лишних сущностей.
        Монады и необходимость следить за типами означают, что у языка высокий порог вхождения, что делает его неподходящим для первоначального обучения.
        Статическая проверка типов сокращает время выполнения программы, однако увеличивает затраты времени на проверку типов при загрузке скрипта интерпретатору.
        Это также делает Haskell менее удобным для написания скриптов, по скравнению с языками с динамической типизацией.

        Haskell --- краткий и элегантный язык~\cite{haskell}.
        В нём используется минимум ключевых слов.
        Например, для определения функции во многих языках необходимо использование ключевых слов (например, \verb!define! в Scheme или \verb!function! в OCaml).
        Нотация в целом похожа на математическую.
        Также, как в Python вместо скобок, ограничивающих блоки кода (Scheme, C, JavaScript) и разделительных знаков (C, OCaml) в нём используются отступы.
        Отступы в Haskell являются <<синтаксическим сахаром>> (синтаксической возможностью, не влияющей на выполнение программы, но упрощающей написание кода).
        Фактически препроцессор компилятора заменяет их на ограничивающий блок (\verb${}$) и разделители ($;$).
        Это делает код легче для восприятия, так как сразу видна вложенность.
        Однако, в отличие от Python, где отступы обязаны быть одинаковыми, в Haskell важно лишь, чтобы отступ вложенной операции был больше родительской.

        Пример вычисления факториала числа на языке Haskell:

        \lstinputlisting{examples/haskell_factorial.hs}

    \subsection{Выбор концепций для языка}
        %Традиционно скрипт --- это текст, а не байт-код или нативный код, даже если скрипт компилируется.
        Язык разрабатывается для написания скриптов, первоначального обучения программированию и исследовательского программирования.

        Для этих целей больше подходит динамическая типизация, как в Scheme для большей гибкости и краткости кода.

        Чтобы снизить порог вхождения Язык должен быть содержать минимум ключевых слов и разделяющих знаков, как в Haskell.

        Для лучшего понимания программы запись функций и результат их вычислений должен быть приближен к математической.
        Для работы с математическими формулами необходимы символьные вычисления (Scheme, Prolog).

        Короткие программы легче поддерживать.
        И, как правило, в них меньше возможности допустить ошибку.
        Для краткости кода в нём должно быть реализовано сопоставление с образцом как в OCaml и повторное использование переменных как в Prolog.

        Для оптимизации рекурсивных функций (таких как функция вычисления факториала и чисел фибоначчи) необходима возможность мемоизации функций (как в языке Haskell).

        Функция вычисления факториала числа на Языке должна выглядеть следующим образом:

        \lstinputlisting{examples/factorial}

    \subsection{Выбор языка реализации и целевого языка для компилятора}
        Для реализации динамической типизации удобнее всего выбрать язык с таким типом типизации.
        Таковым является язык Scheme.

        Символьные вычисления также реализованы в Scheme.

        Для реализации была выбрана спецификация языка R5RS, так как она поддерживается всеми известными компиляторами (!!! Guile, Chicken, Racket).
