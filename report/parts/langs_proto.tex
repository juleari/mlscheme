% Языки-прототипы -- 3
\section{Языки-прототипы}
    \subsection{Lisp, Scheme}
        $Lisp$ (LISt Processing language) -- функциональный язык программирования с динамической типизацией. 
        Он был создан для символьной обработки данных.\cite{p_c_lisp}
        $Scheme$ -- диалект Lisp'а, использующий хвостовую рекурсию и статические области видимости переменных.\cite{scheme_doc}
        Scheme -- высокоуровевый язык общего назначения, поддерживающие операции над такими структурами данных как строки, списки и векторы.
        Scheme используется для написания текстовых редакторов, оптимизирующих компиляторов, операционных систем, графических пакетов и экспертных систем, вычислительных приложений и систем виртуальной реальности.
        
        В Scheme реализована <<сборка мусора>>.
        
        Все объекты, в том числе функции, являются данными первого порядка, что позволяет присваивать функции переменным, возвращать функции и принимать их в качестве аргументов.
        Все переменные и ключевые слова объедены в области видимости, а программы на языке имеют блочную структуру.
        
        Как и во многих других языках программирования процедуры на языке Scheme могут быть рекурсивными.
        Все хвостовые рекурсии оптимизируются.

        Scheme поддерживает определение произвольных структур с помощью \textit{продолжений}.
        Продолжения сохраняют текущее состояние программы и позволяют продолжить выполнение с этого момента из любой точки программы.
        Этот механизм удобен для перебора с возвратом, многопоточности и сопрограмм.

        Scheme также позволяет создавать синтаксические расширения для написания процедур трансформации новх синтаксических форм в существующие.\cite{scheme_pl}

        В Scheme используется префиксная нотация.
        Выражения являются списками с оператором во главе этого списка.
        Такой способ записи позволяет, например, сложить сразу несколько значений.
        Но выражения с несколькими операторами трудны для восприятия и нагромождены большим количеством скобок.

        Функции на языке Scheme могут иметь произвольное число аргументов.
        Тем переменным, наличие которых необходимо, присваиваются имена, а остальные можно получить из списка оставшихся.

    \subsection{Prolog}
        $Prolog$ (PROgramming in LOGic) -- язык, объединяющий в себе логическое и алгоритмическое программирование.
        Он используется в системах обработки естественных языков, исследованиях искуственного интеллекта и экспертных систем.

        Ключевыми особенностями языка Prolog являются унификация и перебор с возвратом.
        Унификация показывает как две произвольные структуры могут быть равными.
        Процессоры Prolog'а используют стратегию поиска, которая пытается найти решение проблемы перебором с возвратом по всем возможным путям, пока один из них не приведёт к решению\cite{prolog}

        Язык использует сопоставление с образцом (в том числе повторное использование).
        Программа на языке Prolog представляет собой набор фактов и правил.
        В прологе отсутствует логическое отрицание, поэтому в условиях нет ветки <<иначе>>.

        Входной точкой в программу на языке Prolog является запрос.
        Ответом на него может быть либо список подошедших шаблонов, либо \verb!false!, означающий, что совпадений не найдено.

    \subsection{ML, OCaml}
        $ML$ (Meta Language) -- семейство языков с полиморфным выводом типов и обработкой исключений.
        Языки ML не являются чистыми функциональными языками.
        
        $OCaml$ -- самый распространённый в практической работе диалект ML.

        Он включает в себя <<сборку мусора>> для автоматического управления памятью.
        Как и в Lisp, функции являются объектами первого класса.

        OCalm использует статическую проверкую типов, что позволяет увеличить скорость сократить количество ошибок во время исполнения.
        Но присутствует параметрический полиморфизм, что даёт возможность создавать абстракции и работать с разными типами данных.
        Механизм автоматического вывода типов позволяет избегать тщательного определения типа каждой переменной, вычисляя его по тому как она используется.
        Кроме того, в OCaml, как и в Scheme, есть поддержка неизменяемых данных.
        Также, поддерживаются алгебраические типы данных и сопоставление с образцом, чтобы определять и управлять сложными структурами данных.\cite{ocaml}

    \subsection{Haskell}
        $Haskell$ -- чистый функциональный язык программирования.
        Это означает, что результат вычислений, производимых функциями не зависит от состояния программы.
        Он зависит только от набора входных параметров, а значит уже вычисленные значения не изменятся.
        А значит при следующем вызове функции с таким же набором входных параметров это значение можно уже не вычислять.

        Кроме того, Haskell является ленивым, что позволяет не вычислять значения, пока это не нужно.

        Haskell обладает статической сильной полной типизацией с атоматическим выводом типов.
        
        Также, Haskell поддерживает функции высшего порядка и частичное применение.

        Haskell -- краткий и элегантный.\cite{haskell}
        В языке отсутствуют лишние ключевые слова такие как \verb!define! в Scheme или \verb!function! в OCaml для определения функций.
        Также, как в Python вместо скобок, ограничивающих блоки кода (Scheme, C, JavaScript) и разделительных знаков (C, OCaml) в нём используются отступы.
        Это делает код легче для восприятия, так как сразу видна вложенность.
        Однако, в отличие от Python, где отступы обязаны быть одинаковыми, в Haskell важно лишь, чтобы отступ вложенной операции был больше родительской.

        Короткие программы легче поддерживать.
        И, как правило, в них меньше возможности допустить ошибку.

    \subsection{}
        Разрабатываемый язык должен быть содержать минимум ключевых слов и разделяющих знаков, как в Haskell.
        При этом, он должен быть с динамической типизацией, как Scheme \verb!WHY??!.
        В нём должно быть сопоставление с образцом как в OCaml и повторное использование переменных как в Prolog.
