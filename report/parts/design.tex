% Дизайн языка --- 3
\section{Разработка языка}
    \subsection{Критерии эффективности языка}
        Для разрабатываемого языка выбраны следующие критерии оценки:
        \begin{itemize}
            \item читабельность (легкость чтения и понятность программы)
            \item лёгкость написания программ
            \item надёжность (обработка исключительных ситуаций)
            \item стоимость
        \end{itemize}
    \subsection{Описание языка}
        Разрабатываемый язык должен быть удобен для написания коротких программ, скриптов, а также для первоначального обучения программированию.
        Поэтому сам язык должен быть максимально краток и понятен для разработчика.
        В языке должны отсутствовать лишние ключевые слова и управляющие конструкции.
        Для математических формул обязательна инфиксная нотация.

        В разрабатываемом языке есть два вида стрелок.
        Стрелка влево (\verb!<-!) означает, что фрагменту слева присвается выражение справа.
        Эта стрелка используется, например, для присваивания значения функции или простой переменной.

        Стрелка вправо (\verb!->!) означает, что из левой части следует правая.
        В математике стрелкой вправо обозначается импликация.
        Она применяется, например, в условном операторе $if$.
        В случае выполнения одного из условий при переходе по стрелке будет вычислено выражение, следующее за ней.
        
        Другой случай применения этой стрелки --- безымянные функции.
        В математике стрелка вправо также отвечает за отображение области определения на область значений.
        Безымянные (lambda) функции фактически являются преобразованием своих аргументов в итоговое значение.
        В функциональных языках программирования функции являются объектами первого класса, то есть не отличаются от других типов.
        Анонимные функции фактически являются значением типа <<функция>>, а значит, такой функции не может быть присвоено значение.
        Поэтому после аргументов $lambda$-функции следует стрелка вправо, за которой следует нужное выражение.

        Объявление функций состоит из имени функции, её аргументов и тела функции.
        Аргументами функции могут быть имена переменных, числа, списки и <<продолжения>>.
        Объявлений у функции может быть несколько.
        При вызове функции её аргументы сопоставляются с представленными образцами и возвращается значение первого подошедшего варианта.
        Если в списке аргументов одно имя используется несколько раз, то эти аргументы при проверке будут считаться равными.

        <<Продолжения>> в списке аргументов --- это списки из 0 и более аргументов, которые используются, когда количество аргументов функции неизвестно.

        Для определения вложенных конструкций, например, функций внутри функции, должны использоваться отступы.
        Отступ вложенной конструкции должен быть больше, чем отступ внешней.
        Таким образом, проверяется только наличие отступа, но ограничений на его размер не налагается.
        Это может использоваться для улучшения восприятия длинных констрункций, <<табличного>> форматирования кода.

        В примере ниже мы видим определение функции filter.
        $Filter$ --- функция высшего порядка (то есть функция, которая принимает функции в качестве аргументов).
        Традиционно эта функция входит в стандартную библиотеку функциональных языков программирования в числе функций высшего порядка для обработки списков (map, reduce, fold).
        Она принимает два аргумента.
        Первый ($pred?$) --- предикат --- функция одного аргумента, возвращающая логическое значение.
        Второй --- список.
        Функция filter должна вернуть список всех значений исходного списка, для которых выполнено условие pred?.

        Как видно в первой строке, в случае, если второй аргумент --- пустой список, то мы получим пустой список.
        Во второй строке в качестве второго аргумента мы видим список, состоящий из как минимум одного элемента $x$ и <<продолжения>> $xs$.
        По отступу в третьей строке мы понимаем, что условная конструкция $if$ относится ко второй строчке определения функции.
        В случае, если выполняется условие $pred?~x$ мы возвращаем конкатенацию списка из одного элемента $x$ и результат рекурсивного вызова функции $filter$ от того же предиката и окончания списка $xs$.
        Если условие выполнено не было, то вычисление продолжится с четвёртой строки, где условие отсутствует и будет осуществлён вызов функции $filter$ от $pred?$ и $xs$.

        \lstinputlisting{examples/filter}

        Для расширения возможностей Языка предусмотрена вставка кода на языке $Scheme$.
        Для этого пишется ключевое слово $scheme$ за которым должна следовать одна конструкция на этом языке.
        Чтобы использовать функции, определённые таким образом их надо экспортировать, используя ключевое слово $export$, после которого должны следовать имена всех функций, которые будут использованы в дальнейшем.

    % Синтаксис ФЯП --- 7
    \subsection{Синтаксис функционального языка программирования}
        Программа на Языке представляет собой набор выражений, определений функций и их вызовов.
        
        В отличие от Scheme, Язык является регистрозависимым.
        Например, $item$, $Item$ и $ITEM$ --- три различных идентификатора.
        Это приучет начинающего программиста аккуратней относится к обозначениям в коде.
        Кроме того, такой код понятней.
        Когда в одном месте функция названа $item$, ниже вызывается словом $Item$ --- не сразу становится понятно о чём идёт речь.

        Далее представлен синтаксис Языка в расширенной форме Бэкуса-Наура (РБНФ)\cite{skor}.

        \subsubsection{Токены}
            Существуют следующие виды токенов: идентификатор, число, строка, операторы и ключевые слова.
            Пробельные символы игнорируются, если они не существенны для разделения двух последовательных токенов.

            \begin{itemize}
                \item Число --- целочисленная, вещественная константа, дробь или комплексное число.
                Число (в том числе дробь и вещественное число) может быть записано в шестнадцатеричной системе счисления.
                Запись числа в Языке соответствует принятой в языке программирования Scheme.

                Примеры чисел: \verb!#xA9.F!, \verb!4/7!, \verb#2+7i#, \verb!#x7/ad!.
                \lstinputlisting{syntax/number}
                \item Идентификатор --- последовательность символов, исключающая пробельные символы, точки, скобки, кавычки, двоеточие.
                В отличие от большинства языков идентификаторы могут начинаться с цифр.
                В этом случае идентификатор целиком не должен являться числом.

                Примеры идентификаторов: \verb#day-of-week#, \verb#0->1#, \verb#nil?#, \verb#%2!0?#.
                \lstinputlisting{syntax/ident}
                \item Строки --- последовательности символов, заключённые в двойные(") кавычки.
                
                Примеры строк: \verb#"valid string"#, \verb#"it's a beautiful day"#.
                \item Булевые константы --- константы, представляющие логические значения <<истина>> и <<ложь>>.
                
                Истина: \verb!#t!. Ложь: \verb!#f!.
                \lstinputlisting{syntax/bool}
                \item Операторы и ключевые слова --- специальные символы, пары символов и слова, зарезервированные компилятором Языка и нижлежащим компилятором Scheme.

                Зарезервированные ключевые слова, символы и сочетания символов представлены в таблице~\ref{tabular:kw}.
                \clearpage
                \begin{table}[ht!]
                    \caption{Ключевые слова и зарезервированные символы\bigskip}
                    \centering
                    \label{tabular:kw}
                    \begin{tabular}{|c|l|}
                        \hline
                        \bf{Слово,}                 & \multirow{2}{*}{\bf{Описание}} \\
                        \bf{символ}                 & \\ \hline
                        $scheme$                    & позволяет использовать код на языке Scheme \\ \hline
                        \multirow{2}{*}{$export$ }  & позволяет использовать функции, определённые в коде \\
                                                    & на Scheme с помощью ключевого слова scheme \\ \hline
                        $sin$, $cos$,               & тригонометрические функции, вычисляющие синус, косинус, \\
                        $tg$, $ctg$                 & тангенс, котангенс аргумента \\ \hline
                        $mod$                       & находит остаток от деления числа $x$ на число $y$ \\ \hline
                        $div$                       & находит результат целочисленного деления числа $x$ на число $y$ \\ \hline
                        $abs$                       & находит модуль числа \\ \hline
                        $even?/$                    & \multirow{2}{*}{находит результат проверки числа на чётность/нечётность} \\
                        $odd?$                      & \\ \hline
                        \verb!gcd!                  & находит наибольший общий делитель двух чисел \\ \hline
                        \verb!lcm!                  & находит наименьшее общее кратное двух чисел \\ \hline
                        $round$                     & округляет число до ближайшего целого\\ \hline
                        \verb!expt!                 & возводит первый аргумент в степень, равную второму аргументу \\ \hline
                        \verb!sqrt!                 & находит корень из числа \\ \hline
                        \multirow{2}{*}{$not$}      & возвращает логическое значение,\\
                                                    & противоположное значению аргумента \\ \hline
                        $eq?$,                      & проверки на равенство. $eq?$, $eqv?$ проверяют равенство адресов,\\
                        $eqv?$,                     & на которые ссылаются аргументы.\\
                        $equal?$                    & $equal$ сравнивает значения \\ \hline
                        $zero?$                     & проверяет, является ли аргумент числом 0 \\ \hline
                        $null?$                     & проверяет, является ли аргумент пустым списком \\ \hline
                        $reverse$                   & переворачивает список \\ \hline
                        $eval$                      & зарезервировано компилятором языка Scheme \\ \hline
                        $if$                        & условный оператор \\ \hline
                        $|$                         & маркер начала условного оператора в конструкции if \\ \hline
                        \verb$!, &&, ||, ^$         & логические операторы (отрицание, и, или, исключающее или) \\ \hline
                        $<$, $<=$, $>$,             & \multirow{2}{*}{операторы сравнения} \\
                        $>=$, $=$, $!=$             & \\ \hline
                        \multirow{2}{*}{$( ) [ ] \{ \}$} & различные виды скобок для математических выражений,\\
                                                    & списков и областей определения} \\ \hline
                        $.$                         & \verb,f.x, -- применить функцию \verb,f, к списку аргументов \verb,x, \\ \hline
                        $:$                         & для записи <<продолжений>> списков \verb,[x : xs], \\ \hline
                        \verb$\$                    & определение анонимной функции \verb,\ x -> x + 1, \\ \hline
                        \verb$<-$                   & оператор связывания переменной~/~функции со значением \\ \hline
                        \verb$->$                   & оператор имликации и отношения \\ \hline
                        $-$, $+$, $++$              & математические операторы (вычитание, сложение, конкатенация\\
                        $/$, $//$, $\%$,            & деление, целочисленное деление, остаток от деления,\\
                        $*$, $**$                   & умножение, возведение в степень)} \\ \hline
                    \end{tabular}
                \end{table}
            \end{itemize}
            \clearpage
        \subsubsection{Объявление функций}
            Функции делятся на именованные и безымянные $\lambda$-функции.
            Объявление именованных функций (FunctionDefinition) состоит из имени функции, её аргументов, знака присваивания $\leftarrow$ и тела функции.
            Аргументами функции при объявлении могут быть:
            \begin{itemize}
                \item идентификаторы, не являющиеся ключевыми словами (SimpleIdent);
                \item числа (Number);
                \item списки, не содержащие выражений (ListDeclaration);
                \item и <<продолжение>> списка аргументов (ContinuousDeclaration) --- этот элемент может быть в списке аргументов только последним и он заменяет все аргументы, которые могут быть переданы в эту функцию после уже объявленных.
            \end{itemize}
            
            \lstinputlisting{syntax/func_def}

            Объявление безымянных функций (LambdaFunction) похоже на объявление именных.
            Вместо идентификатора, отвечающего за имя функции, используется символ \verb,\,.

            \lstinputlisting{syntax/lambda}

            Функции Языка являются объектами первого класса.
            Это демонстрирует частный случай определения функции, где её телом является lambda-функция.

        \subsubsection{Тело функции}
            Тело функции, также может содержать в себе определения функций.
            Тело функции обязательно содержит хотя бы одно выражение.
            Выражений может быть несколько, но вернёт функция только последнее выражение.

            Все выражения и определения внутри тела функции должны иметь больший отступ, чем имя этой функции.

            При написании тела функции рекомендуется записывать длинные конструкции в несколько строк, с соблюдением отступов.
            Нет строгой проверки на величину отступов, поэтому следить за тем, что отстутпы одинаковы программисту придётся самостоятельно.

            \lstinputlisting{syntax/func_body}

        \subsubsection{Выражение}
            Выражение (Expression) может быть
            \begin{itemize}
                \item условным выражением (IfExpression);
                \item безымянной функцией (LambdaFunction);
                \item математическим выражением (MathExpression).
            \end{itemize}

            \lstinputlisting{syntax/expr}

        \subsubsection{Условный оператор}
            Условный оператор $if$ похож на оператор $cond$ в $Scheme$.
            Структура его аргументов устроена следующим образом:
            \begin{enumerate}
                \item после вертикальной черты (\verb,|,) следует условие.
                    В случае если условие отсутствует, считается, что условие истинно.
                    Таким образом, опустив условие можно организовать ветку $else$ для привычных условных операторов
                    или $default$ для $switch-case$ оператора;
                \item после импликации (\verb,->,) следует выражение, которое выполнится, если условие перед стрелочкой было выполнено.
                    Если условие было выполнено, то после вычисления выражения действие оператора заканчивается и остальные условия не проверяются.
                    Если условие выполнено не было --- переходим к проверке следующего условия.
            \end{enumerate}

            \lstinputlisting{syntax/if}

            Пример использования конструкции $if$:

            \lstinputlisting{examples/sign-if}

        \subsubsection{Математическое выражение}
            Математическое выражение может быть
            \begin{itemize}
                \item строкой или конкатинацией строк (StringExpression);
                \item вызовом функции (FunctionCall) или применением функции к списку аргументов (FunctionApply);
                \item списком или конкатинацией списков (ListExpression).
                    Элементы списка при этом не могут содержать вызов функции.
                    Поэтому, если это необходимо, то нужно использовать применение функции к списку аргументов.
                \item применением операторов к математическим выражениям;
                \item объединением математических выражений с помощью операторов и скобок.
            \end{itemize}
            
            \lstinputlisting{syntax/math_expr}

        \subsubsection{Вставки на Scheme}
            Для использования кода на $Scheme$ необходимо написать ключевое слово $scheme$.
            После него может следовать только одна конструкция на $Scheme$, заключённая в скобки.
            Если необходимо описать сразу несколько конструкций, то нужно либо объединить их в конструкцию $begin$, либо писать ключевое слово $scheme$ перед каждой.
            
            \lstinputlisting{syntax/scheme}

            Если необходимо использовать функции, описанные на языке $Scheme$ в дальнейшем коде, то нужно их экспортировать.
            Сделать это можно с помощью ключевого слова $export$.
            После него должны быть перечислены имена всех функций, которые будут использоваться.
            
            \lstinputlisting{syntax/export}

        \subsubsection{Комментарии}
            Любая последовательность символов после символа $;$ и до символа переноса строки является комментарием и будет проигнорирована компилятором.

            \lstinputlisting{syntax/comment}

        \subsubsection{Программа}
            Программа представляет собой набор определений функций, выражений, комментариев и вставок на языке Scheme.

            \lstinputlisting{syntax/program}
