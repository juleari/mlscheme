% Дизайн языка -- 2
\section{Описание языка}
    Разрабатываемый язык должен быть удобен для написания коротких программ, скриптов, а также для первоначального обучения программированию.
    Поэтому сам язык должен быть максимально краток и понятен для разработчика.
    В языке должны отсутствовать лишние ключевые слова и управляющие конструкции.
    Для математических формул обязательна инфиксная нотация.

    В разрабатываемом языке есть два вида стрелочек.
    Стрелка влево (\verb!<-!) означает, что фрагменту слева присвается выражение справа.
    Эта стрелка используется, например, для присваивания значения функции или простой переменной.

    Стрелка вправо (\verb!->!) означает, что из левой части следует правая.
    Она применяется, например, в условном операторе $if$.
    В случае выполнения одного из условий при переходе по стрелке после него мы попадём в выражение, которое необходимо вычислить.
    Другой случай применения этой стрелки -- безымянные функции.
    Так как $lambda$-функции используются только один раз, то мы не можем присвоить им какое-то значение.
    Такие функции являются преобразованием аргументов в значение.
    Поэтому после аргументов $lambda$-функции следует стрелка вправо, за которой следует нужное выражение.

    Объявление функций состоит из имени функции, её аргументов и тела функции.
    Аргументами функции могут быть имена переменных, числа, списки и <<продолжения>>.
    Объявлений у функции может быть несколько.
    При вызове функции её аргументы сопоставляются с представленными образцами и возвращается значение первого подошедшего варианта.
    Если в списке аргументов одно имя используется несколько раз, то эти аргументы при проверки будут считаться равными.

    <<Продолжения>> в списке аргументов это списки из 0 и более аргументов, которые используются, когда количество аргументов функции не известно.

    Для определения вложенных конструкций, например, функций внутри функции, должны использоваться отступы.
    Отступ вложенной конструкции должен быть больше, чем отступ внешней.
    Это может использоваться и для улучшения восприятия длинных констрункций.

    В примере ниже мы видим определение функции filter.
    Она принимает два аргумента.
    Первый ($pred?$) -- предикат. 
    Второй -- список.
    Как видно в первой строке, в случае, если второй аргумент -- пустой список, то мы получим пустой список.
    Во второй строке в качестве второго аргумента мы видим список, состоящий из как минимум одного элемента $x$ и <<продолжения>> $xs$.
    По отступу в третьей строке мы понимаем, что условная конструкция $if$ относится ко второй строчке определения функции.
    В случае, если выполняется условие $pred? x$ мы возвращаем конкатенацию списка из одного элемента $x$ и результат рекурсивного вызова функции $filter$ от того же предиката и окончания списка $xs$.
    Если условие выполнено не было мы перейдём на четвёртую строчку, где условие отсутствует и мы просто получим вызов функции $filter$ от $pred?$ и $xs$.

    \lstinputlisting{examples/filter}

    Для расширения возможностей языка предусмотрена возможность вставки кода на языке $Scheme$.
    Для этого пишется ключевое слово $scheme$ за которым должна следовать одна конструкция на этом языке.
    Чтобы использовать функции, определённые таким образом их надо экспортировать, используя ключевое слово $export$, после которого должны следовать имена всех функций, которые вы собираетесь дальше использовать.
