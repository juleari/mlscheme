% Дизайн языка --- 3
\section{Разработка языка}
    \subsection{Критерии эффективности языка}
        \textit{Эффективность} определяет степень соответствия языка программирования своему назначению.
        Она измеряется либо количеством затрат, необходимых для получения определённого результата, либо результатом, полученным при определённых затратах.
        Определить эффективность конкретного языка позволяют \textit{критерии эффективности} (правила, служащие для сравнительной оценки качества различных языков программирования)~\cite{evm}.

        Основные критерии эффективности для разрабатываемого языка:
        \begin{itemize}
            \item читабельность (легкость чтения и понятность программы);
            \item лёгкость написания программ;
            \item надёжность (обработка исключительных ситуаций);
            \item стоимость (суммарная стоимость всего жизненного цикла языка);
            \item переносимость (легкость переноса программ на языке из одной операционной системы в другую).
        \end{itemize}

        \subsubsection{Читабельность}
            Одним из важнейших критериев качества языка является легкость чтения и понимания программ, написанных на нём.
            По современным представленнием, самым длительным этапом времени жизни программы является её сопровождение, в ходе которого неё вносятся какие-то изменения.
            Так как читабельность программы влияет на лёгкость сопровождения, то её считают существенной характеристикой качества программ и языков программирования~\cite{langs}.

            На читабельность кода оказывают влияние следующие факторы:
            \begin{itemize}
                \item простота;
                \item ортогональность;
                \item структурированность потока управления в программе.
            \end{itemize}

            Язык должен предоставить простой набор конструкций, которые могут быть использованы в качестве базисных элементов при создании программы.
            Желательно обеспечить минимальное количество различных понятий с простыми правилами их комбинирования.
            Этому мешает наличие в языке нескольких способов описания одного действия.
            На простоту влияет синтаксис языка.
            Он должен максимально прозрачно отражать семантику языка и исключать двусмысленность толкования~\cite{langs}.

            \textit{Ортогональность} означает, что любые возможные комбинации различных языковых конструкций будут осмысленными без непредвиденных ограничений или неожиданного поведения, возникающих в результате взаимодействия конструкций или контекста использования~\cite{langs}.
            Например, язык содержит следующие элементарные типы данных: число, строка.
            Также в языке присутствуют конструкции: список и функция.
            Возможность применения этих конструкций к самим себе говорят об их ортогональности, обеспечивающей большое количество структур данных.

            Когда конструкции языка ортогональны, язык легче выучить и использовать для чтения и написания программ, так как в нём меньше исключительных и специальных случаев, которые необходимо запомнить.
            Однако, излишняя ортогональность может стать источником проблем.
            Например, в ходе компиляции не генерируются ошибки, даже при наличии комбинаций, которые лишены логического смысла или крайне неэффективны при исполнении~\cite{langs}.
            Таким образом, простота языка достигается комбинированием небольшого числа элементарных конструкций языка и ограниченного применения ортогональности.

            \textit{Структурированность потока управления в программе} означает, что порядок передачи управления между операторами программы должен быть удобен для чтения и понимания программы.

        \subsubsection{Лёгкость написания программ}
            Лёгкость написания программ, отражает удобство использования языка для написания программ в конкретной предметной области.
            Характеристики лёгкости написания программ во многом пересекаются с характеристиками читабельности.

            \textit{Концептуальная целостность} включает в себя следующие взаимосвязанные компоненты:
            \begin{itemize}
                \item простота;
                \item ортогональность;
                \item единообразие понятий.
            \end{itemize}

            \textit{Простота} предполагает использование минимального числа понятий.
            \textit{Ортогональность} позволяет комбинировать любые языковые конструкции.
            \textit{Единообразие понятий} требует единого подхода к описанию и использованию всех понятий~\cite{langs}.

            Простота языка достигается за счёт уменьшения количества случайных ограничений на использование сложных языковых конструкций.
            Например, при реализации массивов следует разрешить их создание для любого типа данных.
            Какие-либо ограничения будут усложнением языка.
            Это также относится и к типам аргументов функций и возращаемых значений.
            В частности, функции должны уметь принимать и возвращать функции.

            Простота уменьшает затраты на обучение программистов и вероятность ошибок, возникающих из-за неправильной интерпретации программистом языковых конструкций~\cite{langs}.
            Если язык содержит слишком большой набор конструкций, то программист может не знать каждую из них.
            Это приводит к неправильному или неэффективному использованию одних и игнорированию других конструкций.
            Можно сделать вывод о преимуществе использования небольшого набора элементарных конструкций и их комбинаций, над применением большого числа конструкций.
        
            \textit{Выразительность} языка характеризует следущее:
            \begin{itemize}
                \item наличие мощных средств для создания структур и описания действий, позволяющих описать большой объём вычислений в виде относительно маленькой программы;
                \item возможность записи вычислений в компактной и удобной форме.
            \end{itemize}
        \subsubsection{Надёжность}
            \textit{Надёжность} --- способность программы выполнять требуемые функции при заданных условиях и в течение определённого периода времени~\cite{langs}.
            Как правило уровень надёжности зависит от степени автоматического обнаружения ошибок.
            Надёжный язык позволяет выявить большое количество ошибок во время компиляции программы, а не во время выполнения, так как это минимизирует стоимость ошибок.

            Высокую надёжность обеспечивает проверка типов.
            Она характерна для языков со статической типизацией.
            Языки с динамической типизацией осуществляют эту проверку только во время выполнения программы.

            Важным критерием надёжности является качество механизма \textit{обработки исключений} --- большинство ошибок должно быть найдено и, по возможности, устранено для последующей работы программы.

            Читабельность и лёгкость написания программ на языке оказывают прямое воздействие на надёжность программ, написанных на нём.
            Чем выше значения этих показателей, тем надёжнее будет программа~\cite{langs}.
        \subsubsection{Стоимость}
            \textit{Стоимость} складывается из нескольких составляющих:
            \begin{itemize}
                \item стоимость разработки, тестирования и использования программы;
                \item стоимость компиляции программы;
                \item стоимость выполнения программы;
                \item стоимость сопровождения программы.
            \end{itemize}

            Стоимость разработки, тестирования, использования программы во многом зависит от читабельности и лёгкости написания программ на языке.

            Стоимость компиляции зависит от количества проверок, осуществляемых во время компиляции.
            К ним относятся проверки типов и обработки лексических, синтаксических и семантических ошибок.

            Стоимость выполнения во многом зависит от структуры языка и от того, какой объём проверок был оставлен компилятором для осуществления во время выполнения.
            Таким образом, чем выше стоимость компиляции, тем ниже скорость выполнения.

            Многочисленные исследования показали, что значительная часть стоимости программы приходится на стоимость сопровождения.
            Сопровождение включает в себя:
            \begin{itemize}
                \item обработку ошибок (17\% времени и стоимости);
                \item изменения, связанные с обновлением опреационного окружения (18\% времени и стоимости);
                \item усовершенствование и расширение функций программы (65\% времени и стоимости).
            \end{itemize}

            Сопровождение программ зависит от читабельности, так как часто сопровождение осуществляется не авторами программы, а другими лицами~\cite{langs}.
        \subsubsection{Переносимость}
            Под \textit{переносимостью} (\textit{портированием}) подразумевается возможность, скомпилировав код один раз запускать его на различных платформах.
            В таком случае переносимость языка напрямую зависит от переносимости целевого языка компилятора.
    \subsection{Описание языка}
        Разрабатываемый язык должен быть удобен для написания коротких программ, скриптов, а также для первоначального обучения программированию.
        Поэтому сам язык должен быть максимально краток и понятен для разработчика.
        В языке должны отсутствовать лишние ключевые слова и управляющие конструкции.
        Для математических формул обязательна инфиксная нотация.
        Для простоты языка запись функций на нём должна быть близка к их записи в математике.

        Для повышения ортогональности языка, основные его конструкции должны быть примениммы к себе и друг другу.

        Элементарными конструкциями языка являются числа, идентификаторы и строки.
        Основные составные конструкции языка --- списки и функции.
        Выражение на языке является комбинацией операторов и основных конструкций.

        Функции в языке похожи на математические.
        Они могут иметь аргументы и должны возращать значение.
        Функции могут являться функциями высшего порядка, то есть аргументы и возвращаемые значения могут быть функциями.
        Это обеспечивает высокую ортогональность и простоту языка, а также читабельность программ, написанных на нём.

        Для повышения читабельности и простоты языка было решено добавить в него сопоставление с образцом.
        Это позволяет использовать числа и списки, а не только идентификаторы, для определения аргументов функций.
        При этом, в определении функции аргументы не могут являться сложными выражениями: в списке аргументов в определении функции не должно быть вызовов функций и применения операторов.
        Это ограничение имеет смысл, так как его отсутствие противоречило бы смыслу определения функции.

        Сопоставление с образцом осуществляется сверху вниз.
        При успешном сопоставлении остальные образцы не проверяются.
        Это означает, что писать шаблоны нужно от частных к общим.

        Наиболее общим шаблоном для для одного аргумента является идентификатор.
        Встретив идентификатор, компилятор проверит только наличие этого аргумента при вызове функции, но не будет проверять его значение.

        Наиболее общим образцом для списка аргументов является конструкция

        \verb!: ident!,

        где \verb!ident! --- простой идентификатор.
        При таком обозначении не имеет значение даже количество аргументов (их может не быть вовсе).
        Этот шаблон подойдёт для вызова функции с любым количеством аргументов.
        В теле функции эти аргументы будут доступны в виде списка, обратиться к которому можно будет по заданному идентификатору (в данном случае \verb!ident!).

        Конструкция, описанная выше (\verb!: ident!), в разрабатываемом языке называется \textit{продолжением}.
        Она соответствует 

        В разрабатываемом языке есть два вида стрелок.
        Стрелка влево (\verb!<-!) означает, что фрагменту слева присвается выражение справа.
        Эта стрелка используется, например, для присваивания значения функции или простой переменной.

        Стрелка вправо (\verb!->!) означает, что из левой части следует правая.
        В математике стрелкой вправо обозначается импликация.
        Она применяется, например, в условном операторе $if$.
        В случае выполнения одного из условий при переходе по стрелке будет вычислено выражение, следующее за ней.
        
        Другой случай применения этой стрелки --- безымянные функции.
        В математике стрелка вправо также отвечает за отображение области определения на область значений.
        Безымянные (lambda) функции фактически являются преобразованием своих аргументов в итоговое значение.
        В функциональных языках программирования функции являются объектами первого класса, то есть не отличаются от других типов.
        Анонимные функции фактически являются значением типа <<функция>>, а значит, такой функции не может быть присвоено значение.
        Поэтому после аргументов $lambda$-функции следует стрелка вправо, за которой следует нужное выражение.

        Объявление функций состоит из имени функции, её аргументов и тела функции.
        Аргументами функции могут быть имена переменных, числа, списки и <<продолжения>>.
        Объявлений у функции может быть несколько.
        При вызове функции её аргументы сопоставляются с представленными образцами и возвращается значение первого подошедшего варианта.
        Если в списке аргументов одно имя используется несколько раз, то эти аргументы при проверке будут считаться равными.

        <<Продолжения>> в списке аргументов --- это списки из 0 и более аргументов, которые используются, когда количество аргументов функции неизвестно.

        Для определения вложенных конструкций, например, функций внутри функции, должны использоваться отступы.
        Отступ вложенной конструкции должен быть больше, чем отступ внешней.
        Таким образом, проверяется только наличие отступа, но ограничений на его размер не налагается.
        Это может использоваться для улучшения восприятия длинных констрункций, <<табличного>> форматирования кода.

        В примере ниже мы видим определение функции filter.
        $Filter$ --- функция высшего порядка (то есть функция, которая принимает функции в качестве аргументов).
        Традиционно эта функция входит в стандартную библиотеку функциональных языков программирования в числе функций высшего порядка для обработки списков (map, reduce, fold).
        Она принимает два аргумента.
        Первый ($pred?$) --- предикат --- функция одного аргумента, возвращающая логическое значение.
        Второй --- список.
        Функция filter должна вернуть список всех значений исходного списка, для которых выполнено условие pred?.

        Как видно в первой строке, в случае, если второй аргумент --- пустой список, то мы получим пустой список.
        Во второй строке в качестве второго аргумента мы видим список, состоящий из как минимум одного элемента $x$ и <<продолжения>> $xs$.
        По отступу в третьей строке мы понимаем, что условная конструкция $if$ относится ко второй строчке определения функции.
        В случае, если выполняется условие $pred?~x$ мы возвращаем конкатенацию списка из одного элемента $x$ и результат рекурсивного вызова функции $filter$ от того же предиката и окончания списка $xs$.
        Если условие выполнено не было, то вычисление продолжится с четвёртой строки, где условие отсутствует и будет осуществлён вызов функции $filter$ от $pred?$ и $xs$.

        \lstinputlisting{examples/filter}

        Для расширения возможностей Языка предусмотрена вставка кода на языке $Scheme$.
        Для этого пишется ключевое слово $scheme$ за которым должна следовать одна конструкция на этом языке.
        Чтобы использовать функции, определённые таким образом их надо экспортировать, используя ключевое слово $export$, после которого должны следовать имена всех функций, которые будут использованы в дальнейшем.

    % Синтаксис ФЯП --- 7
    \subsection{Синтаксис функционального языка программирования}
        Программа на Языке представляет собой набор выражений, определений функций и их вызовов.
        
        В отличие от Scheme, Язык является регистрозависимым.
        Например, $item$, $Item$ и $ITEM$ --- три различных идентификатора.
        Это приучет начинающего программиста аккуратней относится к обозначениям в коде.
        Кроме того, такой код понятней.
        Когда в одном месте функция названа $item$, ниже вызывается словом $Item$ --- не сразу становится понятно о чём идёт речь.

        Далее представлен синтаксис Языка в расширенной форме Бэкуса-Наура (РБНФ)\cite{skor}.

        \subsubsection{Токены}
            Существуют следующие виды токенов: идентификатор, число, строка, операторы и ключевые слова.
            Пробельные символы игнорируются, если они не существенны для разделения двух последовательных токенов.

            \begin{itemize}
                \item Число --- целочисленная, вещественная константа, дробь или комплексное число.
                Число (в том числе дробь и вещественное число) может быть записано в шестнадцатеричной системе счисления.
                Запись числа в Языке соответствует принятой в языке программирования Scheme.

                Примеры чисел: \verb!#xA9.F!, \verb!4/7!, \verb#2+7i#, \verb!#x7/ad!.
                \lstinputlisting{syntax/number}
                \item Идентификатор --- последовательность символов, исключающая пробельные символы, точки, скобки, кавычки, двоеточие.
                В отличие от большинства языков идентификаторы могут начинаться с цифр.
                В этом случае идентификатор целиком не должен являться числом.

                Примеры идентификаторов: \verb#day-of-week#, \verb#0->1#, \verb#nil?#, \verb#%2!0?#.
                \lstinputlisting{syntax/ident}
                \item Строки --- последовательности символов, заключённые в двойные(") кавычки.
                
                Примеры строк: \verb#"valid string"#, \verb#"it's a beautiful day"#.
                \item Булевые константы --- константы, представляющие логические значения <<истина>> и <<ложь>>.
                
                Истина: \verb!#t!. Ложь: \verb!#f!.
                \lstinputlisting{syntax/bool}
                \item Операторы и ключевые слова --- специальные символы, пары символов и слова, зарезервированные компилятором Языка и нижлежащим компилятором Scheme.

                Зарезервированные ключевые слова, символы и сочетания символов представлены в таблице~\ref{tabular:kw}.
                \clearpage
                \begin{table}[ht!]
                    \caption{Ключевые слова и зарезервированные символы\bigskip}
                    \centering
                    \label{tabular:kw}
                    \begin{tabular}{|c|l|}
                        \hline
                        \bf{Слово,}                 & \multirow{2}{*}{\bf{Описание}} \\
                        \bf{символ}                 & \\ \hline
                        $scheme$                    & позволяет использовать код на языке Scheme \\ \hline
                        \multirow{2}{*}{$export$ }  & позволяет использовать функции, определённые в коде \\
                                                    & на Scheme с помощью ключевого слова scheme \\ \hline
                        $sin$, $cos$,               & тригонометрические функции, вычисляющие синус, косинус, \\
                        $tg$, $ctg$                 & тангенс, котангенс аргумента \\ \hline
                        $mod$                       & находит остаток от деления числа $x$ на число $y$ \\ \hline
                        $div$                       & находит результат целочисленного деления числа $x$ на число $y$ \\ \hline
                        $abs$                       & находит модуль числа \\ \hline
                        $even?/$                    & \multirow{2}{*}{находит результат проверки числа на чётность/нечётность} \\
                        $odd?$                      & \\ \hline
                        \verb!gcd!                  & находит наибольший общий делитель двух чисел \\ \hline
                        \verb!lcm!                  & находит наименьшее общее кратное двух чисел \\ \hline
                        $round$                     & округляет число до ближайшего целого\\ \hline
                        \verb!expt!                 & возводит первый аргумент в степень, равную второму аргументу \\ \hline
                        \verb!sqrt!                 & находит корень из числа \\ \hline
                        \multirow{2}{*}{$not$}      & возвращает логическое значение,\\
                                                    & противоположное значению аргумента \\ \hline
                        $eq?$,                      & проверки на равенство. $eq?$, $eqv?$ проверяют равенство адресов,\\
                        $eqv?$,                     & на которые ссылаются аргументы.\\
                        $equal?$                    & $equal$ сравнивает значения \\ \hline
                        $zero?$                     & проверяет, является ли аргумент числом 0 \\ \hline
                        $null?$                     & проверяет, является ли аргумент пустым списком \\ \hline
                        $reverse$                   & переворачивает список \\ \hline
                        $eval$                      & зарезервировано компилятором языка Scheme \\ \hline
                        $if$                        & условный оператор \\ \hline
                        $|$                         & маркер начала условного оператора в конструкции if \\ \hline
                        \verb$!, &&, ||, ^$         & логические операторы (отрицание, и, или, исключающее или) \\ \hline
                        $<$, $<=$, $>$,             & \multirow{2}{*}{операторы сравнения} \\
                        $>=$, $=$, $!=$             & \\ \hline
                        \multirow{2}{*}{$( ) [ ] \{ \}$} & различные виды скобок для математических выражений,\\
                                                    & списков и областей определения \\ \hline
                        $.$                         & \verb,f.x, -- применить функцию \verb,f, к списку аргументов \verb,x, \\ \hline
                        $:$                         & для записи <<продолжений>> списков \verb,[x : xs], \\ \hline
                        \verb$\$                    & определение анонимной функции \verb,\ x -> x + 1, \\ \hline
                        \verb$<-$                   & оператор связывания переменной~/~функции со значением \\ \hline
                        \verb$->$                   & оператор имликации и отношения \\ \hline
                        $-$, $+$, $++$              & математические операторы (вычитание, сложение, конкатенация\\
                        $/$, $//$, $\%$,            & деление, целочисленное деление, остаток от деления,\\
                        $*$, $**$                   & умножение, возведение в степень) \\ \hline
                    \end{tabular}
                \end{table}
            \end{itemize}
            \clearpage
        \subsubsection{Объявление функций}
            Функции делятся на именованные и безымянные $\lambda$-функции.
            Объявление именованных функций (FunctionDefinition) состоит из имени функции, её аргументов, знака присваивания $\leftarrow$ и тела функции.
            Аргументами функции при объявлении могут быть:
            \begin{itemize}
                \item идентификаторы, не являющиеся ключевыми словами (SimpleIdent);
                \item числа (Number);
                \item списки, не содержащие выражений (ListDeclaration);
                \item и <<продолжение>> списка аргументов (ContinuousDeclaration) --- этот элемент может быть в списке аргументов только последним и он заменяет все аргументы, которые могут быть переданы в эту функцию после уже объявленных.
            \end{itemize}
            
            \lstinputlisting{syntax/func_def}

            Объявление безымянных функций (LambdaFunction) похоже на объявление именных.
            Вместо идентификатора, отвечающего за имя функции, используется символ \verb,\,.

            \lstinputlisting{syntax/lambda}

            Функции Языка являются объектами первого класса.
            Это демонстрирует частный случай определения функции, где её телом является lambda-функция.

        \subsubsection{Тело функции}
            Тело функции, также может содержать в себе определения функций.
            Тело функции обязательно содержит хотя бы одно выражение.
            Выражений может быть несколько, но вернёт функция только последнее выражение.

            Все выражения и определения внутри тела функции должны иметь больший отступ, чем имя этой функции.

            При написании тела функции рекомендуется записывать длинные конструкции в несколько строк, с соблюдением отступов.
            Нет строгой проверки на величину отступов, поэтому следить за тем, что отстутпы одинаковы программисту придётся самостоятельно.

            \lstinputlisting{syntax/func_body}

        \subsubsection{Выражение}
            Выражение (Expression) может быть
            \begin{itemize}
                \item условным выражением (IfExpression);
                \item безымянной функцией (LambdaFunction);
                \item математическим выражением (MathExpression).
            \end{itemize}

            \lstinputlisting{syntax/expr}

        \subsubsection{Условный оператор}
            Условный оператор $if$ похож на оператор $cond$ в $Scheme$.
            Структура его аргументов устроена следующим образом:
            \begin{enumerate}
                \item после вертикальной черты (\verb,|,) следует условие.
                    В случае если условие отсутствует, считается, что условие истинно.
                    Таким образом, опустив условие можно организовать ветку $else$ для привычных условных операторов
                    или $default$ для $switch-case$ оператора;
                \item после импликации (\verb,->,) следует выражение, которое выполнится, если условие перед стрелочкой было выполнено.
                    Если условие было выполнено, то после вычисления выражения действие оператора заканчивается и остальные условия не проверяются.
                    Если условие выполнено не было --- переходим к проверке следующего условия.
            \end{enumerate}

            \lstinputlisting{syntax/if}

            Пример использования конструкции $if$:

            \lstinputlisting{examples/sign-if}

        \subsubsection{Математическое выражение}
            Математическое выражение может быть
            \begin{itemize}
                \item строкой или конкатинацией строк (StringExpression);
                \item вызовом функции (FunctionCall) или применением функции к списку аргументов (FunctionApply);
                \item списком или конкатинацией списков (ListExpression).
                    Элементы списка при этом не могут содержать вызов функции.
                    Поэтому, если это необходимо, то нужно использовать применение функции к списку аргументов.
                \item применением операторов к математическим выражениям;
                \item объединением математических выражений с помощью операторов и скобок.
            \end{itemize}
            
            \lstinputlisting{syntax/math_expr}

        \subsubsection{Вставки на Scheme}
            Для использования кода на $Scheme$ необходимо написать ключевое слово $scheme$.
            После него может следовать только одна конструкция на $Scheme$, заключённая в скобки.
            Если необходимо описать сразу несколько конструкций, то нужно либо объединить их в конструкцию $begin$, либо писать ключевое слово $scheme$ перед каждой.
            
            \lstinputlisting{syntax/scheme}

            Если необходимо использовать функции, описанные на языке $Scheme$ в дальнейшем коде, то нужно их экспортировать.
            Сделать это можно с помощью ключевого слова $export$.
            После него должны быть перечислены имена всех функций, которые будут использоваться.
            
            \lstinputlisting{syntax/export}

        \subsubsection{Комментарии}
            Любая последовательность символов после символа $;$ и до символа переноса строки является комментарием и будет проигнорирована компилятором.

            \lstinputlisting{syntax/comment}

        \subsubsection{Программа}
            Программа представляет собой набор определений функций, выражений, комментариев и вставок на языке Scheme.

            \lstinputlisting{syntax/program}
