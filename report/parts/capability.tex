\section{Возможности языка}
    \subsection{Сопоставление с образцом}
    Под \verb,сопосталением с образцом, в языках программирования подразумевается метод анализа и обработки данных, основанный на выполнении каких-либо действий в зависимости от совпадения данных с образцом.
    Такими образцами могут служить:
    \begin{itemize}
        \item конкретное значение (например, числовая константа);
        \item предикат --- функция, возвращающая логическое значение;
        \item тип данных (проверка принадлежности элемента типу);
        \item какая-то другая конструкция языка.
    \end{itemize}

    В разработанном языке сопоставление с образцом используется для объявления функций.
    При сопоставлении с образцом в списке аргументов функции, в качестве образца могут использоваться:
    \begin{itemize}
        \item идентификаторы (в том числе повторяющиеся);
        \item числа;
        \item списки (в том числе списки списков);
        \item <<хвосты>> списков (в том числе в виде списков).
    \end{itemize}

    Предикаты не разрешены в качестве образца.
    Логика сопоставления с образцом в данном языке подразумевает полное соответствие.
    Если нужно проверять выполнение какого-то более сложного условия, чем простое равенство, то необходимо использовать условную конструкцию \verb,if,.
    
    Чтобы продемонстрировать возможности сопоставления с образцом рассмотрим следующий пример:

    \lstinputlisting{examples/0?}

    В этом примере мы видим определение функции \verb,0?,, которая проверяет является ли входной аргумент числом \verb,0,.
    В первой строке происходит сопоставление аргумента с нулём.
    Если сравнение оказалось успешным, то функция вернёт истинное значение (\verb,#t,).
    Если сравнение оказалось неудачным, выполнение продолжится во второй строке, где образец-идентификатор \verb,x, --- универсален для обозначения одного аргумента.
    
    Рассмотрим более сложный пример сопоставления с образцом: функцию 0->1, которая заменяет все вхождения числа \verb,0, на \verb,1,.
    \lstinputlisting{examples/0->1}

    В первой строке мы видедем образец пустого списка.
    В случае, если функции подан на вход пустой список --- он и будет возвращён.

    Во второй строке программы, аргументом функции является список, первым элементом которого, является число \verb,0,.
    Это число нужно заменить на 1 и рекурсивно вызвать функцию \verb,0->1, для <<хвоста>> списка \verb,xs,.

    В третьей строке программы, аргумент является списком, первым элементом которого является список.
    Первым элементом внутреннего списка, является число \verb,0, --- первым элементом вычисленного списка будет являться список, первый элемент которого равен \verb,0,.

    В четвёртой строке --- аргумент также является списком, первым элементом которого является список.
    Но, так как образец из предыдущей строки не подошёл, первый элемент внутреннего списка не является нулём, а значит, его не нужно заменять, однако замена может быть нужна как для какого-то количества элементов <<хвоста>> внутреннего списка (\verb,xs,), так и для какого-то количества элементов <<хвоста>> внешнего списка (\verb,ys,).
    Поэтому осуществляется рекурсивный вызов функции \verb$0->1$ для этих списков (\verb,xs,, \verb,ys,).

    Наконец, в пятой строке аргументом является список, первый элемент которого не яляется нулём или списком, содержащим ноль.
    Для функции, вызванной с таким элементом, будет осуществлён рекурсивный вызов для <<хвоста>> списка \verb,xs,.
    
    \subsection{Повторные переменные}
    Одной из характерных особенностей разработанного языка является возможность использования повторных переменных в образцах.

    Когда в шаблоне два элемента имеют одно и то же имя, эти элементы считаются равными.
    Следовательно, для того, чтобы сопоставление с таким образцом прошло успешно, необходимо соблюдение равенства соответствующих элементов.

    Рассмотрим следующий пример:

    \lstinputlisting{examples/element}

    В этом примере определяется предикат \verb,element?,, который возвращает логическое значение \verb,#t, (истина), если первый аргумент этой функции, является элементом второго.

    В первой строке программы вторым аргументом является пустой список.
    Так как никакой элемент не входит в пустой список, \verb,element?, от этого набора аргументов вернёт логическое значение \verb,#f, (ложь).

    Во второй строке, первым аргументом функции является идентификатор \verb,x,, в то время как второй аргумент, является списком, первым элементом которого является идентификатор \verb,x,.
    Равенство идентификаторов в одной области видимости подразумевает равенство значений элементов, соответствующих этим идентификатам.
    А значит, первый аргумент функции является элементом второго аргумента.
    Поэтому функция \verb,element, в данном случае вернёт логическое значение \verb,#t, (истина).

    В третьей строке первый аргумент \verb$x$ не равен первому элементу списка, являющегося вторым аргументом, поэтому для того, чтобы определить является ли первый аргумент элементом второго, нужно осуществить рекурсивный вызов этой функции с таким же первым аргументом~(\verb,x,) и <<хвостом>> второго аргумена~(\verb,ys,).

    \subsection{Мемоизация}

    Мемоизация --- это сохранение результатов выполнения функции с целью предотвращения повторных вычислений.

    Мемоизация очень полезна для функций с большим количеством вычислений.
    При её использовании вычисления будут произведены только один раз, а затем они будут получены из памяти.

    Как правило мемоизация используется для таких функций как функция вычисления \verb,n,~-~ного числа ряда Фибоначчи или Трибоначчи.
    Эти функции рекурсивны и объём вычислений возрастает пропорционально элементам этих рядов.
    Без мемоизации эти функции работают очень долго и глубина рекурсии растёт очень быстро, что делает их вычисление очень затратными.

    При мемоизации этих функций количество рекурсивных вызовов ограничено числом \verb,n,. потому что вместо них будут использоваться сохранённые ранее значения.

    Мемоизация в разработанном языке осуществляется с помощью ключевого слова \verb,memo,.

    Рассмотрим следующий пример:

    \lstinputlisting{examples/memo_fibonacci}

    В примере выше описывается функция вычисления \verb,n,~-~ного числа Фибоначчи и указывается, что для этой функции нужно использовать мемоизацию.
