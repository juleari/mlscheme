% Синтаксис ФЯП -- 3
\section{Синтаксис функционального языка программирования}
%\addcontentsline{toc}{section}{Синтаксис функционального языка программирования}
    Для описания синтаксиса языка используются расширенная форма Бэкуса-Наура (РБНФ). 
    Альтернатива обозначается символом '|'. 
    '*' после выражения означает, что оно может быть включено $0$ и более раз, '+' - $1$ и более, '?' - $0$ или $1$ раз.\cite{skor}
    Нетерминальные символы начинаются с заглавной буквы. 
    Терминальные либо начинаются малой буквой, либо состоят целиком из заглавных букв.
    Правила записываются в виде \verb!Идентификатор ::= выражение!,
    где идентификатор -- нетерминал, а выражение -- соответствующая правилам РБНФ комбинация терминальных и нетерминальных символов и специальных знаков.
    Точка в конце — специальный символ, указывающий на завершение правила.

    Язык является регистрозависимым.

    \subsection{Словарь и представление}
        Существуют следующие виды токенов: идентификатор, число, строка, операторы и ключевые слова.
        Пробельные символы игнорируются, если они не существенны для разделения двух последовательных токенов.

        \begin{itemize}
            \item Число -- целочисленная, вещественная константа, дробь или комплексное число.
            Число (в том числе дробь и вещественное число) может быть записано в шестнадцатеричной системе счисления.
            
            Примеры чисел: \verb!#xA9.F!, \verb!4/7!, \verb#2+7i#, \verb!#x7/ad!.
            \lstinputlisting{syntax/number}
            \item Идентификатор -- последовательность символов, исключающая пробельные символы, точки, скобки, кавычки, двоеточие.
            В отличие от большинства языков идентификаторы могут начинаться с цифр.
            В этом случае идентификатор целиком не должен являться числом.

            Примеры идентификаторов: \verb#day-of-week#, \verb#0->1#, \verb#nil?#, \verb#%2!0?#.
            \lstinputlisting{syntax/ident}
            \item Строки -- последовательности символов, заключённые в двойные(") кавычки.
            
            Примеры строк: \verb#"valid string"#, \verb#"it's a beautiful day"#.
            \item Булевые константы -- константы, отвечающие за истинное и ложное значение.
            
            Истина: \verb!#t!. Ложь: \verb!#f!.
            \lstinputlisting{syntax/bool}
            \item Операторы и ключевые слова -- специальные символы, пары символов и слова, зарезервированные системой.

            Список таких символов: 
            
            \verb,( ) [ ] { } . : \ < <= > >= ! != =,

            \verb,- + ++ / // % * ** | || && ^ <- ->,

            Список таких слов: \verb!scheme!, \verb!mod!, \verb!if!, \verb!zero?!, \verb!eval!, \verb!abs!, \verb!odd?!, \verb!even?!, \verb!div!, \verb!round!, \verb!reverse!,
             \verb!null?!, \verb!not!, \verb!sin!, \verb!cos!, \verb!tg!, \verb!ctg!, \verb!eq?!, \verb!eqv?!, \verb!equal?!, \verb!gcd!, \verb!lcm!, \verb!expt!, \verb!sqrt!.
        \end{itemize}

    \subsection{Объявление функций}
        Функции делятся на именованные и безымянные $\lambda$-функции.
        Объявление именованных функций (FunctionDefinition) состоит из имени функции, её аргументов, знака присваивания $\leftarrow$ и тела функции.
        Аргументами функции при объявлении могут быть 
        \begin{itemize}
            \item идентификаторы, не являющиеся ключевыми словами (SimpleIdent);
            \item числа (Number);
            \item списки, не содержащие выражений (ListDeclaration);
            \item и <<продолжение>> (ContinuousDeclaration) -- этот элемент может быть в списке аргументов только последним и он заменяет все аргументы, которые могут быть переданы в эту функцию после уже объявленных.
        \end{itemize}
        
        \lstinputlisting{syntax/func_def}

        Объявление безымянных функций (LambdaFunction) похоже на объявление именных.
        Вместо идентификатора, отвечающего за имя функции, используется символ \verb,\,.

        \lstinputlisting{syntax/lambda}

    \subsection{Тело функции}
        Тело функции, также может содержать в себе определения функций.
        Тело функции обязательно содержит выражение.
        Выражений может быть несколько, но вернёт функция только последнее выражение.

        Все выражения и определения внутри тела функции должны иметь больший отступ, чем имя этой функции.

        \lstinputlisting{syntax/func_body}

    \subsection{Выражение}
        Выражение (Expression) может быть
        \begin{itemize}
            \item условным выражением (IfExpression);
            \item безымянной функцией (LambdaFunction);
            \item математическим выражением (MathExpression).
        \end{itemize}

        \lstinputlisting{syntax/expr}

    \subsection{Условный оператор}
        Условный оператор $if$ похож на оператор $cond$ в $Scheme$.
        Структура его аргументов устроена следующим образом:
        \begin{enumerate}
            \item после вертикальной черты следует условие.
                В случае если условие отсутствует, считается, что условие истинно.
                Таким образом, опустив условие можно организовать ветку $else$ для привычных условных операторов
                или $default$ для $switch-case$ оператора;
            \item после стрелочки следует выражение, которое выполнится, если условие перед стрелочкой было выполнено.
                Если условие было выполнено, то после вычисления выражения действие оператора заканчивается и остальные условия не проверяются.
                Если условие выполнено не было -- переходим к проверке следующего условия.
        \end{enumerate}

        \lstinputlisting{syntax/if}

        Пример использования конструкции $if$:

        \lstinputlisting{examples/sign-if}

    \subsection{Математическое выражение}
        Математическое выражение может быть
        \begin{itemize}
            \item строкой или конкатинацией строк (StringExpression);
            \item вызовом функции (FunctionCall) или применением функции (FunctionApply);
            \item списком или конкатинацией списков (ListExpression).
                Элементы списка при этом не могут содержать вызов функции.
                Поэтому, если это необходимо, то нужно использовать применение функции к списку аргументов.
            \item объединение математических выражений с помощью операторов и скобок.
        \end{itemize}
        
        \lstinputlisting{syntax/math_expr}
