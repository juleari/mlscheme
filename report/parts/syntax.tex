% Синтаксис ФЯП --- 7
\section{Синтаксис функционального языка программирования}
    Программа на Языке представляет собой набор выражений, определений функций и их вызовов.
    
    В отличие от Scheme, Язык является регистрозависимым.
    Например, $item$, $Item$ и $ITEM$ --- три различных идентификатора.
    Это приучет начинающего программиста аккуратней относится к обозначениям в коде.
    Кроме того, такой код понятней.
    Когда в одном месте функция названа $item$, ниже вызывается словом $Item$ --- не сразу становится понятно о чём идёт речь.

    Далее представлен синтаксис Языка в расширенной форме Бэкуса-Наура (РБНФ)\cite{skor}.

    \subsection{Токены}
        Существуют следующие виды токенов: идентификатор, число, строка, операторы и ключевые слова.
        Пробельные символы игнорируются, если они не существенны для разделения двух последовательных токенов.

        \begin{itemize}
            \item Число --- целочисленная, вещественная константа, дробь или комплексное число.
            Число (в том числе дробь и вещественное число) может быть записано в шестнадцатеричной системе счисления.
            Запись числа в Языке соответствует принятой в языке программирования Scheme.

            Примеры чисел: \verb!#xA9.F!, \verb!4/7!, \verb#2+7i#, \verb!#x7/ad!.
            \lstinputlisting{syntax/number}
            \item Идентификатор --- последовательность символов, исключающая пробельные символы, точки, скобки, кавычки, двоеточие.
            В отличие от большинства языков идентификаторы могут начинаться с цифр.
            В этом случае идентификатор целиком не должен являться числом.

            Примеры идентификаторов: \verb#day-of-week#, \verb#0->1#, \verb#nil?#, \verb#%2!0?#.
            \lstinputlisting{syntax/ident}
            \item Строки --- последовательности символов, заключённые в двойные(") кавычки.
            
            Примеры строк: \verb#"valid string"#, \verb#"it's a beautiful day"#.
            \item Булевые константы --- константы, представляющие логические значения <<истина>> и <<ложь>>.
            
            Истина: \verb!#t!. Ложь: \verb!#f!.
            \lstinputlisting{syntax/bool}
            \item Операторы и ключевые слова --- специальные символы, пары символов и слова, зарезервированные компилятором Языка и нижлежащим компилятором Scheme.

            Зарезервированные ключевые слова, символы и сочетания символов представлены в таблице~\ref{tabular:kw}.
            \clearpage
            \begin{table}[ht!]
                \caption{Ключевые слова и зарезервированные символы\bigskip}
                \centering
                \label{tabular:kw}
                \begin{tabular}{|c|l|}
                    \hline
                    \bf{Слово,}                 & \multirow{2}{*}{\bf{Описание}} \\
                    \bf{символ}                 & \\ \hline
                    $scheme$                    & позволяет использовать код на языке Scheme \\ \hline
                    \multirow{2}{*}{$export$ }  & позволяет использовать функции, определённые в коде \\
                                                & на Scheme с помощью ключевого слова scheme \\ \hline
                    $sin$, $cos$,               & тригонометрические функции, вычисляющие синус, косинус, \\
                    $tg$, $ctg$                 & тангенс, котангенс аргумента \\ \hline
                    $mod$                       & находит остаток от деления числа $x$ на число $y$ \\ \hline
                    $div$                       & находит результат целочисленного деления числа $x$ на число $y$ \\ \hline
                    $abs$                       & находит модуль числа \\ \hline
                    $even?/$                    & \multirow{2}{*}{находит результат проверки числа на чётность/нечётность} \\
                    $odd?$                      & \\ \hline
                    \verb!gcd!                  & находит наибольший общий делитель двух чисел \\ \hline
                    \verb!lcm!                  & находит наименьшее общее кратное двух чисел \\ \hline
                    $round$                     & округляет число до ближайшего целого\\ \hline
                    \verb!expt!                 & возводит первый аргумент в степень, равную второму аргументу \\ \hline
                    \verb!sqrt!                 & находит корень из числа \\ \hline
                    \multirow{2}{*}{$not$}      & возвращает логическое значение,\\
                                                & противоположное значению аргумента \\ \hline
                    $eq?$,                      & проверки на равенство. $eq?$, $eqv?$ проверяют равенство адресов,\\
                    $eqv?$,                     & на которые ссылаются аргументы.\\
                    $equal?$                    & $equal$ сравнивает значения \\ \hline
                    $zero?$                     & проверяет, является ли аргумент числом 0 \\ \hline
                    $null?$                     & проверяет, является ли аргумент пустым списком \\ \hline
                    $reverse$                   & переворачивает список \\ \hline
                    $eval$                      & зарезервировано компилятором языка Scheme \\ \hline
                    $if$                        & условный оператор \\ \hline
                    $|$                         & маркер начала условного оператора в конструкции if \\ \hline
                    \verb$!, &&, ||, ^$         & логические операторы (отрицание, и, или, исключающее или) \\ \hline
                    $<$, $<=$, $>$,             & \multirow{2}{*}{операторы сравнения} \\
                    $>=$, $=$, $!=$             & \\ \hline
                    \multirow{2}{*}{$( ) [ ] \{ \}$} & различные виды скобок для математических выражений,\\
                                                & списков и областей определения} \\ \hline
                    $.$                         & \verb,f.x, -- применить функцию \verb,f, к списку аргументов \verb,x, \\ \hline
                    $:$                         & для записи <<продолжений>> списков \verb,[x : xs], \\ \hline
                    \verb$\$                    & определение анонимной функции \verb,\ x -> x + 1, \\ \hline
                    \verb$<-$                   & оператор связывания переменной~/~функции со значением \\ \hline
                    \verb$->$                   & оператор имликации и отношения \\ \hline
                    $-$, $+$, $++$              & математические операторы (вычитание, сложение, конкатенация\\
                    $/$, $//$, $\%$,            & деление, целочисленное деление, остаток от деления,\\
                    $*$, $**$                   & умножение, возведение в степень)} \\ \hline
                \end{tabular}
            \end{table}
        \end{itemize}
        \clearpage
    \subsection{Объявление функций}
        Функции делятся на именованные и безымянные $\lambda$-функции.
        Объявление именованных функций (FunctionDefinition) состоит из имени функции, её аргументов, знака присваивания $\leftarrow$ и тела функции.
        Аргументами функции при объявлении могут быть:
        \begin{itemize}
            \item идентификаторы, не являющиеся ключевыми словами (SimpleIdent);
            \item числа (Number);
            \item списки, не содержащие выражений (ListDeclaration);
            \item и <<продолжение>> списка аргументов (ContinuousDeclaration) --- этот элемент может быть в списке аргументов только последним и он заменяет все аргументы, которые могут быть переданы в эту функцию после уже объявленных.
        \end{itemize}
        
        \lstinputlisting{syntax/func_def}

        Объявление безымянных функций (LambdaFunction) похоже на объявление именных.
        Вместо идентификатора, отвечающего за имя функции, используется символ \verb,\,.

        \lstinputlisting{syntax/lambda}

        Функции Языка являются объектами первого класса.
        Это демонстрирует частный случай определения функции, где её телом является lambda-функция.

    \subsection{Тело функции}
        Тело функции, также может содержать в себе определения функций.
        Тело функции обязательно содержит хотя бы одно выражение.
        Выражений может быть несколько, но вернёт функция только последнее выражение.

        Все выражения и определения внутри тела функции должны иметь больший отступ, чем имя этой функции.

        При написании тела функции рекомендуется записывать длинные конструкции в несколько строк, с соблюдением отступов.
        Нет строгой проверки на величину отступов, поэтому следить за тем, что отстутпы одинаковы программисту придётся самостоятельно.

        \lstinputlisting{syntax/func_body}

    \subsection{Выражение}
        Выражение (Expression) может быть
        \begin{itemize}
            \item условным выражением (IfExpression);
            \item безымянной функцией (LambdaFunction);
            \item математическим выражением (MathExpression).
        \end{itemize}

        \lstinputlisting{syntax/expr}

    \subsection{Условный оператор}
        Условный оператор $if$ похож на оператор $cond$ в $Scheme$.
        Структура его аргументов устроена следующим образом:
        \begin{enumerate}
            \item после вертикальной черты (\verb,|,) следует условие.
                В случае если условие отсутствует, считается, что условие истинно.
                Таким образом, опустив условие можно организовать ветку $else$ для привычных условных операторов
                или $default$ для $switch-case$ оператора;
            \item после импликации (\verb,->,) следует выражение, которое выполнится, если условие перед стрелочкой было выполнено.
                Если условие было выполнено, то после вычисления выражения действие оператора заканчивается и остальные условия не проверяются.
                Если условие выполнено не было --- переходим к проверке следующего условия.
        \end{enumerate}

        \lstinputlisting{syntax/if}

        Пример использования конструкции $if$:

        \lstinputlisting{examples/sign-if}

    \subsection{Математическое выражение}
        Математическое выражение может быть
        \begin{itemize}
            \item строкой или конкатинацией строк (StringExpression);
            \item вызовом функции (FunctionCall) или применением функции к списку аргументов (FunctionApply);
            \item списком или конкатинацией списков (ListExpression).
                Элементы списка при этом не могут содержать вызов функции.
                Поэтому, если это необходимо, то нужно использовать применение функции к списку аргументов.
            \item применением операторов к математическим выражениям;
            \item объединением математических выражений с помощью операторов и скобок.
        \end{itemize}
        
        \lstinputlisting{syntax/math_expr}

    \subsection{Вставки на Scheme}
        Для использования кода на $Scheme$ необходимо написать ключевое слово $scheme$.
        После него может следовать только одна конструкция на $Scheme$, заключённая в скобки.
        Если необходимо описать сразу несколько конструкций, то нужно либо объединить их в конструкцию $begin$, либо писать ключевое слово $scheme$ перед каждой.
        
        \lstinputlisting{syntax/scheme}

        Если необходимо использовать функции, описанные на языке $Scheme$ в дальнейшем коде, то нужно их экспортировать.
        Сделать это можно с помощью ключевого слова $export$.
        После него должны быть перечислены имена всех функций, которые будут использоваться.
        
        \lstinputlisting{syntax/export}

    \subsection{Комментарии}
        Любая последовательность символов после символа $;$ и до символа переноса строки является комментарием и будет проигнорирована компилятором.

        \lstinputlisting{syntax/comment}

    \subsection{Программа}
        Программа представляет собой набор определений функций, выражений, комментариев и вставок на языке Scheme.

        \lstinputlisting{syntax/program}
