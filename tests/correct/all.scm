(define-syntax eval-i
  (syntax-rules ()
    ((_ x) (eval x (interaction-environment)))))

(define-syntax map-cond
  (syntax-rules ()
    ((_ ((cond-1 value-1) ...)) (cond (cond-1 value-1) ...))))

(define-syntax append-s
  (syntax-rules ()
    ((_ (x ...) (y ...)) (append (list x ...) y ...))))

(define-syntax :and-fold-s
  (syntax-rules ()
    ((_ ()) #t)
    ((_ (x)) x)
    ((_ (x y ...)) (and x (:and-fold-s (y ...))))))

(define (:and-fold xs)
  (or (null? xs)
      (and (car xs)
           (:and-fold (cdr xs)))))

(define (hash f-list a-list)
  (or (null? f-list)
      (and ((eval-i (car f-list)) (car a-list))
           (hash (cdr f-list) (cdr a-list)))))

(define (give-first xs n)
  (if (or (zero? n)
          (null? xs))
      '()
      (cons (car xs) (- n 1))))

(define (multi-list->vector xs)
  (define (helper xs)
    (if (list? xs)
        (apply append (map helper xs))
        (list xs)))
  (list->vector (helper xs)))

(define // quotient)
(define % remainder)
(define ** expt)
(define ++ append)
(define (&& x y) (and x y))

(define (day-of-week . :args) (map-cond (((and ((lambda (:x) (= :x 3)) (length :args)) (hash (quote ((lambda (x) #t) (lambda (x) #t) (lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (day month year) (letrec ((a (// (- 14 month) 12))) (letrec ((y (- year a))) (letrec ((m (- (+ month (* a 12)) 2))) (begin (% (- (+ (+ (+ (+ (+ 7000 day) y) (// y 4)) (// y 400)) (// (* 31 m) 12)) (// y 100)) 7)))))) :args)))))
(define (0->1 . :args) (map-cond (((and ((lambda (:x) (= :x 1)) (length :args)) (hash (quote ((lambda (:x) (and (list? :x) (null? :x))))) :args) ((lambda :args #t) :args)) (apply (lambda (:g_) (let () (begin (quote ())))) :args)) ((and ((lambda (:x) (= :x 1)) (length :args)) (hash (quote ((lambda (:x) (and (list? :x) (:and-fold (cons (>= (length :x) 1) (map (lambda (:lambda-i :xi) ((eval-i :lambda-i) :xi)) (quote ((lambda (x) (eqv? x 0)))) (give-first :x 1)))))))) :args) ((lambda :args #t) :args)) (apply (lambda (:g__) (let ((:g___ (car :g__)) (xs (cdr :g__))) (begin (append-s (1) ((0->1 xs)))))) :args)) ((and ((lambda (:x) (= :x 1)) (length :args)) (hash (quote ((lambda (:x) (and (list? :x) (:and-fold (cons (>= (length :x) 1) (map (lambda (:lambda-i :xi) ((eval-i :lambda-i) :xi)) (quote ((lambda (x) #t))) (give-first :x 1)))))))) :args) ((lambda :args #t) :args)) (apply (lambda (:g____) (let ((x (car :g____)) (xs (cdr :g____))) (begin (append-s (x) ((0->1 xs)))))) :args)))))
(define (count . :args) (map-cond (((and ((lambda (:x) (= :x 2)) (length :args)) (hash (quote ((lambda (x) #t) (lambda (:x) (and (list? :x) (null? :x))))) :args) ((lambda :args #t) :args)) (apply (lambda (x :g_____) (let () (begin 0))) :args)) ((and ((lambda (:x) (= :x 2)) (length :args)) (hash (quote ((lambda (x) #t) (lambda (:x) (and (list? :x) (:and-fold (cons (>= (length :x) 1) (map (lambda (:lambda-i :xi) ((eval-i :lambda-i) :xi)) (quote ((lambda (x) #t))) (give-first :x 1)))))))) :args) ((lambda :args (let ((:v-args (multi-list->vector :args))) (:and-fold-s ((equal? (vector-ref :v-args 0) (vector-ref :v-args 1)))))) :args)) (apply (lambda (x :g______) (let ((:g_______ (car :g______)) (xs (cdr :g______))) (begin (+ 1 (count x xs))))) :args)) ((and ((lambda (:x) (= :x 2)) (length :args)) (hash (quote ((lambda (x) #t) (lambda (:x) (and (list? :x) (:and-fold (cons (>= (length :x) 1) (map (lambda (:lambda-i :xi) ((eval-i :lambda-i) :xi)) (quote ((lambda (x) #t))) (give-first :x 1)))))))) :args) ((lambda :args #t) :args)) (apply (lambda (x :g________) (let ((y (car :g________)) (xs (cdr :g________))) (begin (count x xs)))) :args)))))
(define (fact . :args) (map-cond (((and ((lambda (:x) (= :x 1)) (length :args)) (hash (quote ((lambda (x) (eqv? x 0)))) :args) ((lambda :args #t) :args)) (apply (lambda (:g_________) (begin 1)) :args)) ((and ((lambda (:x) (= :x 1)) (length :args)) (hash (quote ((lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (n) (begin (* n (fact (- n 1))))) :args)))))
(define (sum . :args) (map-cond (((and ((lambda (x) (zero? x)) (length :args)) (hash (quote ()) :args) ((lambda :args #t) :args)) (apply (lambda () (begin 0)) :args)) ((and ((lambda (:x) (>= :x 1)) (length :args)) (hash (quote ((lambda (x) #t))) (give-first :args 1)) ((lambda :args #t) :args)) (apply (lambda (x . xs) (begin (+ x (apply sum xs)))) :args)))))
(define (replace . :args) (map-cond (((and ((lambda (:x) (= :x 3)) (length :args)) (hash (quote ((lambda (x) #t) (lambda (x) #t) (lambda (:x) (and (list? :x) (null? :x))))) :args) ((lambda :args #t) :args)) (apply (lambda (pred? proc :g__________) (let () (begin (quote ())))) :args)) ((and ((lambda (:x) (= :x 3)) (length :args)) (hash (quote ((lambda (x) #t) (lambda (x) #t) (lambda (:x) (and (list? :x) (:and-fold (cons (>= (length :x) 1) (map (lambda (:lambda-i :xi) ((eval-i :lambda-i) :xi)) (quote ((lambda (x) #t))) (give-first :x 1)))))))) :args) ((lambda :args #t) :args)) (apply (lambda (pred? proc :g___________) (let ((x (car :g___________)) (xs (cdr :g___________))) (begin (map-cond (((pred? x) (append-s ((apply proc (list x))) ((replace pred? proc xs)))) (#t (append-s (x) ((replace pred? proc xs))))))))) :args)))))
(define (replicate . :args) (map-cond (((and ((lambda (:x) (= :x 2)) (length :args)) (hash (quote ((lambda (x) #t) (lambda (x) (eqv? x 0)))) :args) ((lambda :args #t) :args)) (apply (lambda (x :g____________) (begin (quote ()))) :args)) ((and ((lambda (:x) (= :x 2)) (length :args)) (hash (quote ((lambda (x) #t) (lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (x n) (begin (append-s (x) ((replicate x (- n 1)))))) :args)))))
(define (cycle . :args) (map-cond (((and ((lambda (:x) (= :x 2)) (length :args)) (hash (quote ((lambda (x) #t) (lambda (x) (eqv? x 0)))) :args) ((lambda :args #t) :args)) (apply (lambda (xs :g_____________) (begin (quote ()))) :args)) ((and ((lambda (:x) (= :x 2)) (length :args)) (hash (quote ((lambda (x) #t) (lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (xs n) (begin (++ xs (cycle xs (- n 1))))) :args)))))
(define (and-fold . :args) (map-cond (((and ((lambda (x) (zero? x)) (length :args)) (hash (quote ()) :args) ((lambda :args #t) :args)) (apply (lambda () (begin #t)) :args)) ((and ((lambda (:x) (>= :x 1)) (length :args)) (hash (quote ((lambda (x) #t))) (give-first :args 1)) ((lambda :args #t) :args)) (apply (lambda (x . xs) (begin (&& x (apply and-fold xs)))) :args)))))
(define (0? . :args) (map-cond (((and ((lambda (:x) (= :x 1)) (length :args)) (hash (quote ((lambda (x) (eqv? x 0)))) :args) ((lambda :args #t) :args)) (apply (lambda (:g______________) (begin #t)) :args)) ((and ((lambda (:x) (= :x 1)) (length :args)) (hash (quote ((lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (x) (begin #f)) :args)))))
(define (nil? . :args) (map-cond (((and ((lambda (:x) (= :x 1)) (length :args)) (hash (quote ((lambda (x) (eqv? x 0)))) :args) ((lambda :args #t) :args)) (apply (lambda (:g_______________) (begin #t)) :args)) ((and ((lambda (:x) (= :x 1)) (length :args)) (hash (quote ((lambda (:x) (and (list? :x) (null? :x))))) :args) ((lambda :args #t) :args)) (apply (lambda (:g________________) (let () (begin #t))) :args)) ((and ((lambda (:x) (= :x 1)) (length :args)) (hash (quote ((lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (x) (begin #f)) :args)))))
(define (%2=0? . :args) (map-cond (((and ((lambda (:x) (= :x 1)) (length :args)) (hash (quote ((lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (x) (begin (= (% x 2) 0))) :args)))))
(define (%2!0? . :args) (map-cond (((and ((lambda (:x) (= :x 1)) (length :args)) (hash (quote ((lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (x) (begin (not (%2=0? x)))) :args)))))
(define a (begin "long string"))
(define (my-gcd . :args) (map-cond (((and ((lambda (:x) (= :x 2)) (length :args)) (hash (quote ((lambda (x) #t) (lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (a b) (letrec ((r (% a b))) (begin (map-cond (((< a b) (my-gcd b a)) ((0? r) b) (#t (my-gcd b r))))))) :args)))))
(define (my-lcm . :args) (map-cond (((and ((lambda (:x) (= :x 2)) (length :args)) (hash (quote ((lambda (x) #t) (lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (a b) (begin (abs (/ (* a b) (my-gcd a b))))) :args)))))
(define (prime? . :args) (map-cond (((and ((lambda (:x) (= :x 1)) (length :args)) (hash (quote ((lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (n) (letrec ((n! (lambda :args (map-cond (((and ((lambda (:x) (= :x 1)) (length :args)) (hash (quote ((lambda (x) (eqv? x 0)))) :args) ((lambda :args #t) :args)) (apply (lambda (:g_________________) (begin 1)) :args)) ((and ((lambda (:x) (= :x 1)) (length :args)) (hash (quote ((lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (n) (begin (* n (n! (- n 1))))) :args))))))) (begin (apply 0? (list (% (+ (apply n! (list (- n 1))) 1) n)))))) :args)))))
(day-of-week 17 5 2016)
(day-of-week 10 4 2016)
(day-of-week 29 3 2016)
(day-of-week 20 4 2016)
(0->1 (list 0 2 7 0 5))
(0->1 (list 0 1 0 1 0))
(count 1 (list 1 2 3 1))
(count 0 (list 1 2 3 4))
(count 5 (list 1 2 3 4 5 5 5))
(fact 5)
(fact 10)
(sum 1 2 3 4)
(apply sum (list 5 6 7 8 9 10))
(replace zero? (lambda (x) (+ x 1)) (list 0 1 2 3 0))
(replace odd? (lambda (x) (* x 2)) (list 1 2 3 4 5 6))
(replace (lambda (x) (> 0 x)) exp (list 0 1 -1 2 -2 3 -3))
(replicate "a" 5)
(replicate (list "a" "b") 3)
(replicate "a" 0)
(cycle (list 0 1) 3)
(cycle (list 'a 'b 'c) 5)
(cycle (quote ()) 0)
(and-fold #f #f #f)
(and-fold #f #f #t)
(and-fold #f #t #t)
(and-fold #t #t #t)
(and-fold)
(0? 0)
(0? 1)
(nil? 0)
(nil? 1)
(nil? (quote ()))
(nil? (list 1 2 3))
(%2=0? 4)
(%2=0? 5)
(%2!0? 1)
(%2!0? 2)
(define (selection-sort pred? xs)
         (define (min-xs xs x)
           (cond ((null? xs)         x)
                 ((pred? (car xs) x) (min-xs (cdr xs) (car xs)))
                 (else               (min-xs (cdr xs) x))))
  
         (define (swap j xs)
           (let ((xj (list-ref xs j))
                 (vs (list->vector xs)))
             (vector-set! vs j (car xs))
             (vector-set! vs 0 xj)
             (vector->list vs)))
  
         (define (ind x xs)
           (- (length xs) (length (member x xs))))
  
         (define (helper xs)
           (if (null? xs)
               '()
               (let ((x (min-xs xs (car xs))))
                 (cons x (helper (cdr (swap (ind x xs) xs)))))))
  
         (helper xs))
(define (insertion-sort pred? xs)
         (define (insert xs ys x)
           (cond ((null? ys) (append xs (list x)))
                 ((pred? (car ys) x) (insert (append xs (list (car ys))) (cdr ys) x))
                 (else               (append xs (list x) ys))))
  
         (define (helper xs ys)
           (if (null? ys)
               xs
               (helper (insert '() xs (car ys)) (cdr ys))))
  
         (helper '() xs))
(selection-sort <= '(9 6 2 4 3 5 7 1 8 0))
(insertion-sort <= '(9 6 2 4 3 5 7 1 8 0))
(replicate a 8)
(my-gcd 3542 2464)
(my-lcm 3 4)
(prime? 11)
(prime? 12)
(prime? 3571)
