(define-syntax :eval-i
  (syntax-rules ()
    ((_ x) (eval x (interaction-environment)))))

(define-syntax :map-cond
  (syntax-rules ()
    ((_ ((cond-1 value-1) ...)) (cond (cond-1 value-1) ...))))

(define-syntax :append-s
  (syntax-rules ()
    ((_ (x ...) (y ...)) (append (list x ...) y ...))))

(define-syntax :and-fold-s
  (syntax-rules ()
    ((_ ()) #t)
    ((_ (x)) x)
    ((_ (x y ...)) (and x (:and-fold-s (y ...))))))

(define (:and-fold xs)
  (or (null? xs)
      (and (car xs)
           (:and-fold (cdr xs)))))

(define (:hash f-list a-list)
  (or (null? f-list)
      (and ((:eval-i (car f-list)) (car a-list))
           (:hash (cdr f-list) (cdr a-list)))))

(define (give-first xs n)
  (if (or (zero? n)
          (null? xs))
      '()
      (cons (car xs)
            (give-first xs (- n 1)))))

(define (multi-list->vector xs)
  (define (helper xs)
    (if (list? xs)
        (apply append (map helper xs))
        (list xs)))
  (list->vector (helper xs)))

(define (:print x)
  (if (list? x)
      (begin (display "[ ")
             (map :print x)
             (display "] "))
      (begin (display x)
             (display " "))))

(define (print . xs)
  (or (and (not (null? xs))
           (:print (car xs))
           (newline)
           (apply print (cdr xs))
      (newline))))

(define // quotient)
(define % remainder)
(define ** expt)
(define (&& x y) (and x y))
(define ++ (lambda :args (if (null? :args)
                             :args
                             (if (string? (car :args))
                                 (apply string-append :args)
                                 (apply append :args)))))

(define :error-func-call "RUNTIME-ERROR: the arguments does not match any types of this function")


(define (day-of-week . :args) (:map-cond (((and ((lambda (:x) (= :x 3)) (length :args)) (:hash (quote ((lambda (x) #t) (lambda (x) #t) (lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (day month year) (letrec ((a (// (- 14 month) 12))) (letrec ((y (- year a))) (letrec ((m (- (+ month (* a 12)) 2))) (% (- (+ (+ (+ (+ (+ 7000 day) y) (// y 4)) (// y 400)) (// (* 31 m) 12)) (// y 100)) 7))))) :args)) (else :error-func-call))))
(define (0->1 . :args) (:map-cond (((and ((lambda (:x) (= :x 1)) (length :args)) (:hash (quote ((lambda (:x) (and (list? :x) (null? :x))))) :args) ((lambda :args #t) :args)) (apply (lambda (:g_) (let () (quote ()))) :args)) ((and ((lambda (:x) (= :x 1)) (length :args)) (:hash (quote ((lambda (:x) (and (list? :x) (:and-fold (cons (>= (length :x) 1) (map (lambda (:lambda-i :xi) ((:eval-i :lambda-i) :xi)) (quote ((lambda (x) (eqv? x 0)))) (give-first :x 1)))))))) :args) ((lambda :args #t) :args)) (apply (lambda (:g__) (let ((:g___ (car :g__)) (xs (cdr :g__))) (:append-s (1) ((0->1 xs))))) :args)) ((and ((lambda (:x) (= :x 1)) (length :args)) (:hash (quote ((lambda (:x) (and (list? :x) (:and-fold (cons (>= (length :x) 1) (map (lambda (:lambda-i :xi) ((:eval-i :lambda-i) :xi)) (quote ((lambda (x) #t))) (give-first :x 1)))))))) :args) ((lambda :args #t) :args)) (apply (lambda (:g____) (let ((x (car :g____)) (xs (cdr :g____))) (:append-s (x) ((0->1 xs))))) :args)) (else :error-func-call))))
(define (count . :args) (:map-cond (((and ((lambda (:x) (= :x 2)) (length :args)) (:hash (quote ((lambda (x) #t) (lambda (:x) (and (list? :x) (null? :x))))) :args) ((lambda :args #t) :args)) (apply (lambda (x :g_____) (let () 0)) :args)) ((and ((lambda (:x) (= :x 2)) (length :args)) (:hash (quote ((lambda (x) #t) (lambda (:x) (and (list? :x) (:and-fold (cons (>= (length :x) 1) (map (lambda (:lambda-i :xi) ((:eval-i :lambda-i) :xi)) (quote ((lambda (x) #t))) (give-first :x 1)))))))) :args) ((lambda :args (let ((:v-args (multi-list->vector :args))) (:and-fold-s ((equal? (vector-ref :v-args 0) (vector-ref :v-args 1)))))) :args)) (apply (lambda (x :g______) (let ((:g_______ (car :g______)) (xs (cdr :g______))) (+ 1 (count x xs)))) :args)) ((and ((lambda (:x) (= :x 2)) (length :args)) (:hash (quote ((lambda (x) #t) (lambda (:x) (and (list? :x) (:and-fold (cons (>= (length :x) 1) (map (lambda (:lambda-i :xi) ((:eval-i :lambda-i) :xi)) (quote ((lambda (x) #t))) (give-first :x 1)))))))) :args) ((lambda :args #t) :args)) (apply (lambda (x :g________) (let ((y (car :g________)) (xs (cdr :g________))) (count x xs))) :args)) (else :error-func-call))))
(define fact (let ((:memo (list))) (lambda :args (let ((:m (assoc :args :memo))) (if :m (cadr :m) (let ((:res (:map-cond (((and ((lambda (:x) (= :x 1)) (length :args)) (:hash (quote ((lambda (x) (eqv? x 0)))) :args) ((lambda :args #t) :args)) (apply (lambda (:g_________) 1) :args)) ((and ((lambda (:x) (= :x 1)) (length :args)) (:hash (quote ((lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (n) (* n (fact (- n 1)))) :args)) (else :error-func-call))))) (set! :memo (cons (list :args :res) :memo)) :res))))))
(define (sum . :args) (:map-cond (((and ((lambda (x) (zero? x)) (length :args)) (:hash (quote ()) :args) ((lambda :args #t) :args)) (apply (lambda () 0) :args)) ((and ((lambda (:x) (>= :x 1)) (length :args)) (:hash (quote ((lambda (x) #t))) (give-first :args 1)) ((lambda :args #t) :args)) (apply (lambda (x . xs) (+ x (apply sum xs))) :args)) (else :error-func-call))))
(define (replace . :args) (:map-cond (((and ((lambda (:x) (= :x 3)) (length :args)) (:hash (quote ((lambda (x) #t) (lambda (x) #t) (lambda (:x) (and (list? :x) (null? :x))))) :args) ((lambda :args #t) :args)) (apply (lambda (pred? proc :g__________) (let () (quote ()))) :args)) ((and ((lambda (:x) (= :x 3)) (length :args)) (:hash (quote ((lambda (x) #t) (lambda (x) #t) (lambda (:x) (and (list? :x) (:and-fold (cons (>= (length :x) 1) (map (lambda (:lambda-i :xi) ((:eval-i :lambda-i) :xi)) (quote ((lambda (x) #t))) (give-first :x 1)))))))) :args) ((lambda :args #t) :args)) (apply (lambda (pred? proc :g___________) (let ((x (car :g___________)) (xs (cdr :g___________))) (:map-cond (((pred? x) (:append-s ((apply proc (list x))) ((replace pred? proc xs)))) (#t (:append-s (x) ((replace pred? proc xs)))))))) :args)) (else :error-func-call))))
(define (replicate . :args) (:map-cond (((and ((lambda (:x) (= :x 2)) (length :args)) (:hash (quote ((lambda (x) #t) (lambda (x) (eqv? x 0)))) :args) ((lambda :args #t) :args)) (apply (lambda (x :g____________) (quote ())) :args)) ((and ((lambda (:x) (= :x 2)) (length :args)) (:hash (quote ((lambda (x) #t) (lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (x n) (:append-s (x) ((replicate x (- n 1))))) :args)) (else :error-func-call))))
(define (cycle . :args) (:map-cond (((and ((lambda (:x) (= :x 2)) (length :args)) (:hash (quote ((lambda (x) #t) (lambda (x) (eqv? x 0)))) :args) ((lambda :args #t) :args)) (apply (lambda (xs :g_____________) (quote ())) :args)) ((and ((lambda (:x) (= :x 2)) (length :args)) (:hash (quote ((lambda (x) #t) (lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (xs n) (++ xs (cycle xs (- n 1)))) :args)) (else :error-func-call))))
(define (and-fold . :args) (:map-cond (((and ((lambda (x) (zero? x)) (length :args)) (:hash (quote ()) :args) ((lambda :args #t) :args)) (apply (lambda () #t) :args)) ((and ((lambda (:x) (>= :x 1)) (length :args)) (:hash (quote ((lambda (x) #t))) (give-first :args 1)) ((lambda :args #t) :args)) (apply (lambda (x . xs) (&& x (apply and-fold xs))) :args)) (else :error-func-call))))
(define (0? . :args) (:map-cond (((and ((lambda (:x) (= :x 1)) (length :args)) (:hash (quote ((lambda (x) (eqv? x 0)))) :args) ((lambda :args #t) :args)) (apply (lambda (:g______________) #t) :args)) ((and ((lambda (:x) (= :x 1)) (length :args)) (:hash (quote ((lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (x) #f) :args)) (else :error-func-call))))
(define (nil? . :args) (:map-cond (((and ((lambda (:x) (= :x 1)) (length :args)) (:hash (quote ((lambda (x) (eqv? x 0)))) :args) ((lambda :args #t) :args)) (apply (lambda (:g_______________) #t) :args)) ((and ((lambda (:x) (= :x 1)) (length :args)) (:hash (quote ((lambda (:x) (and (list? :x) (null? :x))))) :args) ((lambda :args #t) :args)) (apply (lambda (:g________________) (let () #t)) :args)) ((and ((lambda (:x) (= :x 1)) (length :args)) (:hash (quote ((lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (x) #f) :args)) (else :error-func-call))))
(define (%2=0? . :args) (:map-cond (((and ((lambda (:x) (= :x 1)) (length :args)) (:hash (quote ((lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (x) (= (% x 2) 0)) :args)) (else :error-func-call))))
(define (%2!0? . :args) (:map-cond (((and ((lambda (:x) (= :x 1)) (length :args)) (:hash (quote ((lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (x) (not (%2=0? x))) :args)) (else :error-func-call))))
(define str "long string")
(define (my-gcd . :args) (:map-cond (((and ((lambda (:x) (= :x 2)) (length :args)) (:hash (quote ((lambda (x) #t) (lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (a b) (letrec ((r (% a b))) (:map-cond (((< a b) (my-gcd b a)) ((0? r) b) (#t (my-gcd b r)))))) :args)) (else :error-func-call))))
(define (my-lcm . :args) (:map-cond (((and ((lambda (:x) (= :x 2)) (length :args)) (:hash (quote ((lambda (x) #t) (lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (a b) (abs (/ (* a b) (my-gcd a b)))) :args)) (else :error-func-call))))
(define prime? (let ((:memo-prime?-n! (list))) (lambda :args (:map-cond (((and ((lambda (:x) (= :x 1)) (length :args)) (:hash (quote ((lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (n) (letrec ((n! (lambda :args (let ((:m (assoc :args :memo-prime?-n!))) (if :m (cadr :m) (let ((:res (:map-cond (((and ((lambda (:x) (= :x 1)) (length :args)) (:hash (quote ((lambda (x) (eqv? x 0)))) :args) ((lambda :args #t) :args)) (apply (lambda (:g_________________) 1) :args)) ((and ((lambda (:x) (= :x 1)) (length :args)) (:hash (quote ((lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (n) (* n (n! (- n 1)))) :args)) (else :error-func-call))))) (set! :memo-prime?-n! (cons (list :args :res) :memo-prime?-n!)) :res)))))) (apply 0? (list (% (+ (apply n! (list (- n 1))) 1) n))))) :args)) (else :error-func-call))))))
(define (bisection . :args) (:map-cond (((and ((lambda (:x) (= :x 4)) (length :args)) (:hash (quote ((lambda (x) #t) (lambda (x) #t) (lambda (x) #t) (lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (f a b e) (letrec ((sign (lambda :args (:map-cond (((and ((lambda (:x) (= :x 1)) (length :args)) (:hash (quote ((lambda (x) (eqv? x 0)))) :args) ((lambda :args #t) :args)) (apply (lambda (:g__________________) 0) :args)) ((and ((lambda (:x) (= :x 1)) (length :args)) (:hash (quote ((lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (x) (:map-cond (((> x 0) 1) (#t -1)))) :args)) (else :error-func-call)))))) (letrec ((mid (lambda :args (:map-cond (((and ((lambda (:x) (= :x 2)) (length :args)) (:hash (quote ((lambda (x) #t) (lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (a b) (letrec ((x (+ a (/ (- b a) 2)))) (:map-cond (((<= (abs (f x)) e) x) ((= (sign (apply f (list b))) (sign (apply f (list x)))) (mid a x)) (#t (mid x b)))))) :args)) (else :error-func-call)))))) (:map-cond (((= (apply f (list a)) 0) a) ((= (apply f (list b)) 0) b) (#t (mid a b))))))) :args)) (else :error-func-call))))
(define (newton . :args) (:map-cond (((and ((lambda (:x) (= :x 4)) (length :args)) (:hash (quote ((lambda (x) #t) (lambda (x) #t) (lambda (x) #t) (lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (f df x e) (:map-cond (((< (abs (f x)) e) x) (#t (newton f df (- x (/ (apply f (list x)) (apply df (list x)))) e))))) :args)) (else :error-func-call))))
(define (golden . :args) (:map-cond (((and ((lambda (:x) (= :x 4)) (length :args)) (:hash (quote ((lambda (x) #t) (lambda (x) #t) (lambda (x) #t) (lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (f x0 x1 e) (letrec ((fi (/ (+ (sqrt 5) 1) 2))) (letrec ((loop (lambda :args (:map-cond (((and ((lambda (:x) (= :x 4)) (length :args)) (:hash (quote ((lambda (x) #t) (lambda (x) #t) (lambda (x) #t) (lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (f x0 x1 e) (letrec ((a (- x1 (/ (- x1 x0) fi)))) (letrec ((b (+ x0 (/ (- x1 x0) fi)))) (:map-cond (((>= (apply f (list a)) (apply f (list b))) (:map-cond (((< (abs (- x1 a)) e) (/ (+ a x1) 2)) (#t (loop f a x1 e))))) (#t (:map-cond (((< (abs (- b x0)) e) (/ (+ x0 b) 2)) (#t (loop f x0 b e)))))))))) :args)) (else :error-func-call)))))) (loop f x0 x1 e)))) :args)) (else :error-func-call))))
(define (range . :args) (:map-cond (((and ((lambda (:x) (= :x 3)) (length :args)) (:hash (quote ((lambda (x) #t) (lambda (x) #t) (lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (a b d) (:map-cond (((< a b) (++ (list a) (range (+ a d) b d))) (#t (quote ()))))) :args)) (else :error-func-call))))
(define (flatten . :args) (:map-cond (((and ((lambda (:x) (= :x 1)) (length :args)) (:hash (quote ((lambda (:x) (and (list? :x) (null? :x))))) :args) ((lambda :args #t) :args)) (apply (lambda (:g___________________) (let () (quote ()))) :args)) ((and ((lambda (:x) (= :x 1)) (length :args)) (:hash (quote ((lambda (:x) (and (list? :x) (:and-fold (cons (>= (length :x) 1) (map (lambda (:lambda-i :xi) ((:eval-i :lambda-i) :xi)) (quote ((lambda (x) #t))) (give-first :x 1)))))))) :args) ((lambda :args #t) :args)) (apply (lambda (:g____________________) (let ((x (car :g____________________)) (xs (cdr :g____________________))) (++ (flatten x) (flatten xs)))) :args)) ((and ((lambda (:x) (= :x 1)) (length :args)) (:hash (quote ((lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (x) (list x)) :args)) (else :error-func-call))))
(define (element? . :args) (:map-cond (((and ((lambda (:x) (= :x 2)) (length :args)) (:hash (quote ((lambda (x) #t) (lambda (:x) (and (list? :x) (null? :x))))) :args) ((lambda :args #t) :args)) (apply (lambda (x :g_____________________) (let () #f)) :args)) ((and ((lambda (:x) (= :x 2)) (length :args)) (:hash (quote ((lambda (x) #t) (lambda (:x) (and (list? :x) (:and-fold (cons (>= (length :x) 1) (map (lambda (:lambda-i :xi) ((:eval-i :lambda-i) :xi)) (quote ((lambda (x) #t))) (give-first :x 1)))))))) :args) ((lambda :args (let ((:v-args (multi-list->vector :args))) (:and-fold-s ((equal? (vector-ref :v-args 0) (vector-ref :v-args 1)))))) :args)) (apply (lambda (x :g______________________) (let ((:g_______________________ (car :g______________________)) (xs (cdr :g______________________))) #t)) :args)) ((and ((lambda (:x) (= :x 2)) (length :args)) (:hash (quote ((lambda (x) #t) (lambda (:x) (and (list? :x) (:and-fold (cons (>= (length :x) 1) (map (lambda (:lambda-i :xi) ((:eval-i :lambda-i) :xi)) (quote ((lambda (x) #t))) (give-first :x 1)))))))) :args) ((lambda :args #t) :args)) (apply (lambda (x :g________________________) (let ((y (car :g________________________)) (ys (cdr :g________________________))) (element? x ys))) :args)) (else :error-func-call))))
(define (filter . :args) (:map-cond (((and ((lambda (:x) (= :x 2)) (length :args)) (:hash (quote ((lambda (x) #t) (lambda (:x) (and (list? :x) (null? :x))))) :args) ((lambda :args #t) :args)) (apply (lambda (pred? :g_________________________) (let () (quote ()))) :args)) ((and ((lambda (:x) (= :x 2)) (length :args)) (:hash (quote ((lambda (x) #t) (lambda (:x) (and (list? :x) (:and-fold (cons (>= (length :x) 1) (map (lambda (:lambda-i :xi) ((:eval-i :lambda-i) :xi)) (quote ((lambda (x) #t))) (give-first :x 1)))))))) :args) ((lambda :args #t) :args)) (apply (lambda (pred? :g__________________________) (let ((x (car :g__________________________)) (xs (cdr :g__________________________))) (:map-cond (((pred? x) (++ (list x) (filter pred? xs))) (#t (filter pred? xs)))))) :args)) (else :error-func-call))))
(define fibonacci (let ((:memo (list))) (lambda :args (let ((:m (assoc :args :memo))) (if :m (cadr :m) (let ((:res (:map-cond (((and ((lambda (:x) (= :x 1)) (length :args)) (:hash (quote ((lambda (x) (eqv? x 0)))) :args) ((lambda :args #t) :args)) (apply (lambda (:g___________________________) 1) :args)) ((and ((lambda (:x) (= :x 1)) (length :args)) (:hash (quote ((lambda (x) (eqv? x 1)))) :args) ((lambda :args #t) :args)) (apply (lambda (:g____________________________) 1) :args)) ((and ((lambda (:x) (= :x 1)) (length :args)) (:hash (quote ((lambda (x) #t))) :args) ((lambda :args #t) :args)) (apply (lambda (n) (+ (fibonacci (- n 1)) (fibonacci (- n 2)))) :args)) (else :error-func-call))))) (set! :memo (cons (list :args :res) :memo)) :res))))))
(day-of-week 17 5 2016)
(day-of-week 10 4 2016)
(day-of-week 29 3 2016)
(day-of-week 20 4 2016)
(0->1 (list 0 2 7 0 5))
(0->1 (list 0 1 0 1 0))
(count 1 (list 1 2 3 1))
(count 0 (list 1 2 3 4))
(count 5 (list 1 2 3 4 5 5 5))
(fact 5)
(fact 10)
(sum 1 2 3 4)
(apply sum (list 5 6 7 8 9 10))
(replace zero? (lambda (x) (+ x 1)) (list 0 1 2 3 0))
(replace odd? (lambda (x) (* x 2)) (list 1 2 3 4 5 6))
(replace (lambda (x) (> 0 x)) exp (list 0 1 -1 2 -2 3 -3))
(replicate "a" 5)
(replicate (list "a" "b") 3)
(replicate "a" 0)
(cycle (list 0 1) 3)
(cycle (list 'a 'b 'c) 5)
(cycle (quote ()) 0)
(and-fold #f #f #f)
(and-fold #f #f #t)
(and-fold #f #t #t)
(and-fold #t #t #t)
(and-fold)
(0? 0)
(0? 1)
(nil? 0)
(nil? 1)
(nil? (quote ()))
(nil? (list 1 2 3))
(%2=0? 4)
(%2=0? 5)
(%2!0? 1)
(%2!0? 2)
(define (selection-sort pred? xs)
         (define (min-xs xs x)
           (cond ((null? xs)         x)
                 ((pred? (car xs) x) (min-xs (cdr xs) (car xs)))
                 (else               (min-xs (cdr xs) x))))

         (define (swap j xs)
           (let ((xj (list-ref xs j))
                 (vs (list->vector xs)))
             (vector-set! vs j (car xs))
             (vector-set! vs 0 xj)
             (vector->list vs)))

         (define (ind x xs)
           (- (length xs) (length (member x xs))))

         (define (helper xs)
           (if (null? xs)
               '()
               (let ((x (min-xs xs (car xs))))
                 (cons x (helper (cdr (swap (ind x xs) xs)))))))

         (helper xs))
(define (insertion-sort pred? xs)
         (define (insert xs ys x)
           (cond ((null? ys) (append xs (list x)))
                 ((pred? (car ys) x) (insert (append xs (list (car ys))) (cdr ys) x))
                 (else               (append xs (list x) ys))))

         (define (helper xs ys)
           (if (null? ys)
               xs
               (helper (insert '() xs (car ys)) (cdr ys))))

         (helper '() xs))
(selection-sort (lambda (x y) (<= x y)) (list 9 6 2 4 3 5 7 1 8 0))
(insertion-sort (lambda (x y) (<= x y)) (list 9 6 2 4 3 5 7 1 8 0))
(replicate str 8)
(my-gcd 3542 2464)
(my-lcm 3 4)
(prime? 11)
(prime? 12)
(bisection cos -3.0 0.0 0.001)
(round (newton (lambda (x) (** x 2)) (lambda (x) (* 2 x)) 1.0 1.0e-8))
(round (newton (lambda (x) (+ (+ (** x 2) (* 4 x)) 4)) (lambda (x) (+ (* 2 x) 4)) 5.0 1.0e-8))
(round (golden (lambda (x) (** x 2)) -2.0 2.0 1.0e-8))
(round (golden (lambda (x) (+ (+ (** x 2) (* 4 x)) 4)) -5.0 5.0 1.0e-6))
(+ 5 6)
(not 8)
(range 0 11 3)
(flatten (list (list 1) 2 (list 3 (list 4 5) (list 6 (list 7 8))) 9))
(element? 1 (list 3 2 1))
(element? 4 (list 3 2 1))
(filter odd? (apply range (list 0 10 1)))
(filter (lambda (x) (= (% x 3) 0)) (apply range (list 0 13 1)))
(fibonacci 99)
(fibonacci 100)
